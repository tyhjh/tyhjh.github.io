{"pages":[],"posts":[{"title":"Android日志工具的设计","text":"日志工具日志工具是日常开发中必不可少的工具，日志工具的功能一方面是开发时的实时打印，用于进行调试；另一个方面就是输出日志文件，当程序运行出现异常的时候用于定位问题；之前在项目中负责了日志工具的开发工作，最近也有同事咨询日志性能相关的东西，感觉还是有些技巧可以总结一波的。 日志打印功能基本打印对于日志打印，Android提供了Log类用于日志打印，打印日志分不同的等级，便于日志工具的封装，一般使用带日志等级的方法进行打印，而不是直接调用相应等级的方法；其中需要注意的一点是当tag参数TextUtils.isEmpty()时，是不会进行打印输出的； 1234567891011/** * Low-level logging call. * @param priority The priority/type of this log message 日志等级 * @param tag Used to identify the source of a log message. It usually identifies TAG * the class or activity where the log call occurs. * @param msg The message you would like logged. 打印的信息 * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } 打印优化控制台打印出日志后，再根据日志找出打印的位置，代码比较多的时候还是比较耗时的，可以进行模仿AndroidStudio的Exception的打印，点击打印的时候就可以跳转到代码所对应的地方；点击跳转的日志打印固定格式如下 1&quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot;+ targetStackTrace.getLineNumber() + &quot;)&quot; 除此以外，还可以把当前线程和方法名打印出来 12345678910111213141516171819202122232425262728293031/** * 获取日志出处 * * @return */ private static String getTargetStackTraceElement() { StackTraceElement targetStackTrace = null; boolean shouldTrace = false; //获取线程堆栈转储的堆栈跟踪元素数组 StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); //遍历元素数组 for (StackTraceElement stackTraceElement : stackTrace) { //该对象是否是打印日志自身 boolean isLogMethod = stackTraceElement.getClassName().equals(LogUtils.class.getName()); //如果上一个对象是日志工具本身并且该对象不是则证明该对象就是使用日志工具的类 if (shouldTrace &amp;&amp; !isLogMethod) { //保存调用日志工具的对象 targetStackTrace = stackTraceElement; break; } //保存上一个对象是不是打印工具本身 shouldTrace = isLogMethod; } //获取线程名 String tName = Thread.currentThread().getName(); //获取调用日志工具执行的方法 String methodName = targetStackTrace.getMethodName(); //进行拼接 return tName + &quot; -&gt; &quot; + methodName + &quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot; + targetStackTrace.getLineNumber() + &quot;)&quot;; } 也可以在一次打印前后加上一些分割线，这样看起来会更直观、更易用；打印效果如下 具体实现是在进行日志打印的时候拿到线程堆栈转储的堆栈跟踪元素数组，这里面的信息是当前线程的堆栈信息；我们可以对比一下系统的异常输出日志，一般有异常抛出e.printStackTrace会全部输出到控制台，如下图所示；可以看出来第一个输出的是异常抛出的方法，之后都是上级的方法；同理我们获取到线程的堆栈信息后只想打印一下调用日志工具的地方的信息，就需要从这个stackTrace数组里面去找，取第一个的话肯定是日志工具类本身的方法，不是我们想要的，所以代码里面进行了判断，找第一个不是日志工具类的对象就好了；其实这里也可以根据代码直接写死取第几个对象，因为调用日志工具类的方法后执行的方法个数肯定是固定的； 除此以外还可以对特殊格式的字符串进行打印的优化，比如说提供对Json数据进行格式化打印的方法，这个看起来会很方便；具体的实现就是做一些简单的字符替换，网上一大堆这里就不再给出代码； 输入日志到文件输出日志到文件还是比较简单的，只需要开启一个输出流，将打印的日志输出到日志文件中即可； 12345678910111213/** * 写日志到文件，示例简化代码 * @param logMsg */ private void writeLogFile(String logMsg){ FileOutputStream fos = null; String logFilePath =&quot;sdcard/log.txt&quot;; File file = new File(logFilePath); fos = new FileOutputStream(file, true); fos.write(logMsg.getBytes()); //关闭流 fos.close(); } 多线程调用但是如果只是这样实现的话肯定是有问题的，写文件操作肯定是需要考虑性能的，每执行一次方法就会开启一个输出流，会对性能造成很大的影响，很容易出现内存溢出；因此只能开启一个输出流，可以将输出流设置为成员变量每次执行完以后不关闭，APP退出时再进行关闭；但是对于多线程调用，多个线程同时进行写文件操作也可能会出现问题，可以通过synchronized加锁来实现同步； 12345678910111213141516/** * 文件输出流 */ private FileOutputStream mOutputStream; /** * 写日志到文件，示例简化代码 * @param msg */ private synchronized void writeLogFile(String msg){ if(mOutputStream==null){ mOutputStream=new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); } mOutputStream.write(msg.getBytes()); mOutputStream.flush(); } 建立写入缓存区当日志频繁打印的时候，每次打印一行，会不停的执行文件写入操作，效率比较低，会对性能造成一定的影响；可以使用带缓冲区的输出流BufferedOutputStream设置一定的内存缓冲区大小，先把日志数据先写入缓冲区，等缓冲区满了，再把数据写到文件里，能够大量减少 IO 次数，提高效率；但是也是有缺点的，缓冲区设置的越大越能减少IO次数，但是当程序异常退出的时候缓冲区的日志就会丢失掉，设置越大，丢失的越多；下面会讲讲优化方法 123456789101112131415161718/** * 带缓冲区的输出流 */private BufferedOutputStream mOutputStream;/** * 写日志到文件，示例简化代码 * * @param msg */private synchronized void writeLogFile(String msg) { if (mOutputStream == null) { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); mOutputStream = new BufferedOutputStream(fileOutputStream,BUFF_SIZE); } byte[] bytes = msg.getBytes(); mOutputStream.write(bytes,0,bytes.length);} 线程优化写入日志到文件的操作是在子线程进行操作的，在执行加了锁后的方法writeLogFile是内部私有的方法，我们需要对外提供一个方法，因为写文件是个耗时操作，所以这个方法是需要在子线程执行，这时候肯定就会使用线程池；使用线程池就会有线程的创建和回收，日志打印频繁也会对性能造成一定的影响；可以创建一个独立的线程进行写入日志到文件的操作，创建一个缓存区，对外部提供的方法将日志都放在缓冲区里面，线程里面循环从缓存区里面去读出日志，写入到文件中；这个缓存区可以使用一个数组或集合来实现，只要保证读写和删除的效率高即可； 12345678910111213141516171819202122232425262728293031/** * 初始化日志工具，示例简化代码 */ public void init() { openWrite = true; new Thread(new Runnable() { @Override public void run() { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); BufferedOutputStream mOutputStream = new BufferedOutputStream(fileOutputStream, BUFF_SIZE); while (openWrite) { if (msgCache.size() &gt; 0) { byte[] bytes=msgCache.get(0).getBytes(); mOutputStream.write(bytes,0,bytes.length); msgCache.remove(0); } } } }).start(); } /** * 将日志存入缓存区 * * @param msg */ public void writeLogFile(String msg) { if (msgCache.size() &lt; LOG_MSG_CACHE_SIZE) { msgCache.add(msg); } } 这里对于msgCache这个集合也做了大小限制，因为极端情况，如果一直添加日志字符串到集合里面也会造成内存溢出，所以可以设置一下集合的大小控制一下，对于溢出的日志会被舍弃，也算是一个异常处理；讲道理一般情况是不可能出现的，如果出现了不做处理程序的性能肯定也会出问题。做一下计算如果每条日志是20个汉字，就是60个字节，如果缓存区设置为1M的话，也是可以缓存2万多条日志了； 日志缓存区优化感觉上面的做法还是不是特别靠谱，虽然很少几率发生，但是毕竟丢弃日志还是不太友好的；这里可以通过阻塞队列ArrayBlockingQueue代替普通的集合进行存储，初始化的时候需要指定队列的大小，当队列满了的时候会阻塞处理直到队列有空间，就不会主动进行日志的丢弃； 1private ArrayBlockingQueue&lt;String&gt; mCacheLog = new ArrayBlockingQueue(2000); 日志文件压缩日志多了以后日志文件的清理肯定是必要的，不然随着运行时间的延长日志文件会无限大；那么为了保存更多、更久的日志就可以对日志文件进行压缩，Android自带的压缩可以节省大约10以上倍的存储空间 12345678910111213//简写代码//压缩后保存的文件的输出流FileOutputStream fos = new FileOutputStream(zipFile);ZipOutputStream zos = new ZipOutputStream(fos);//原日志文件的输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));ZipEntry entry = new ZipEntry(&quot;&quot; + file.getName());zos.putNextEntry(entry);int count;byte[] buf = new byte[1024];while ((count = bis.read(buf)) != -1) { zos.write(buf, 0, count);} 内存映射文件上面只是一个非常普通的日志工具的实现，由于设置了缓冲区，当APP异常退出的时候就会导致日志的丢失；而且无论怎样优化还是避免不了文件的IO操作，这不是废话吗，功能就是写日志到文件，肯定避免不了； 其实还是有办法进行优化，就是mmap（一种内存映射文件的方法），即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系，函数原型如下 1void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 mmap 的回写时机 内存不足 进程退出 调用 msync 或者 munmap 不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD) 这篇文章介绍的非常不错 Android-内存映射mmap 简单点就是说，mmap操作提供了一种机制，可以让用户程序对内核空间的文件进行读写操作，这种机制不需要再将文件数据从内核空间读写到用户空间，相较于普通的文件读写，减少了一次数据的拷贝，效率更高；而且在内存不足或者进程退出的时候，会将数据写入文件，避免日志丢失的情况； 具体实现可以在C++里面使用mmap函数来实现，就是上面那个函数原型；不过在Java中也提供了内存映射的实现，就是MappedByteBuffer；先看看MappedByteBuffer的用法 1234567RandomAccessFile raf = new RandomAccessFile(sFile, &quot;rw&quot;);raf = new RandomAccessFile(sFile, &quot;rw&quot;);//把文件从0开始到FILE_SIZE映射到内存中MappedByteBuffer mByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, FILE_SIZE);byte[] msgbyte = msg.getBytes();//写入内容mByteBuffer.put(msgbyte); 可以把文件映射到内存中，获取到一个MappedByteBuffer对象，往这里面put数据就会写入到文件中；那么第一个问题，这个FILE_SIZE设置多大生成的日志文件就是多大；设置太大了，在日志没达到这个大小的时候应用退出，就浪费了，尤其是应用异常退出的时候，根本没机会对日志文件进行处理；设置小了，当日志文件达到这个大小的时候需要进行扩展，重新进行映射，这样的操作频繁了就会影响性能； 方案比较测试数据 15byte的日志执行10万次，也就是写入1.43M数据到文件 方案 耗时/ms 普通文件输出流耗时 16756 缓冲区大小为默认大小(8192)的输出流耗时 977 设置内存映射文件，初始映射大小为1M时耗时 1151 冷静分析就时间消耗来看，设置输出流缓冲区和内存映射性能差不多，比普通的输出流效率高了很多；讲道理，不应该是mmap这种黑科技应该要厉害一点吗？我原本也是这样认为的，毕竟内存映射那一大堆不太能懂的描述看起来很厉害的样子。但是我们可以冷静分析一波，具体原理可以看上面那篇Android-内存映射mmap的文章； 这里简单点讲，普通读写文件（就是输入输出流的write和read等操作）是将硬盘的文件加载到内核空间，再复制到用户空间，用户才获取到数据，复制了两遍（这个顺序是从硬盘读文件，反之则是写文件）；而mmap内存映射就是只需要将文件从硬盘加载到内核空间，只复制一次用户就可以拿到数据；所以mmap优势在于少复制一次；但是对于BufferedOutputStream呢，虽然写一次文件需要复制两次，效率低，但是好在我有缓存区呀，我是大大减少了写入的次数；单次写入效率低的问题，就被减小了呀；而再反观mmap虽然你写入的效率极高，但是你没有缓存区，写入的次数毕竟多呀；所以缓存区这个减少写入文件次数的对于效率的提升作用是非常大的，从测试耗时来看设置默认大小的缓存区对性能的提提升有17倍左右； 所以如果给mmap加一个缓冲区，性能肯定会更高，但是加了缓冲区，应用异常退出，日志就可能丢失；鱼和熊掌不可得兼，其实感觉mmap够了，效率够高又能防止日志丢失，好好写写MappedByteBuffer的使用的逻辑还是很不错的。 总结基本上这样的话日志工具应该就差不多能用了，具体实现逻辑的话还是要自己去实现，这里也只是谈到自己遇到的一些可以优化的点，感觉上还是比较简单的。","link":"/me/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"实现Android换肤","text":"之前看过一点关于Android换肤的文章，插件化、Hook、无缝换肤什么的，听起来好像很难的样子，也没有好好看；现在关于换肤的开源项目现在也比较多，但其实原理都差不多；最近看了一下，自己实现了一波，感觉还是很简单的样子；这里也只是讲讲换肤的原理，知道了原理每个点就可以快速学习，然后完成整个流程；具体实现可以看代码； 换肤原理换肤其实很简单，说白了就是修改View的属性，一般就是修改字体颜色、背景、图片等；如果是一个超级简单的界面，最简单的实现方式就是点击换肤的时候把每一个View都重新设置一下属性就完事了； View设置属性简单吧，问题就在于在实际项目中不可能手动去获取到每一个控件进行换肤，因为控件太多了；那么问题就变为如何获取到所有的控件进行属性设置；然后换肤，其实就是换一套皮肤，换一套资源文件对吧，如何去更换资源文件也是一个问题 使用theme实现Activity的theme属性肯定都有用过，theme里面可以设置各种属性，更改了theme里面的属性比如颜色，我们的导航栏什么的使用了theme里面的颜色属性的控件颜色都会改变；可以从这个点入手，设置不同的theme，然后更换theme就可以实现；但是有一个问题，设置theme只有在activity的setContentView之前才有效，所以要实现换肤必须得重启Activity才能实现，而且每次新增皮肤必须重新修改源码，重新打包，这种方法感觉不太行； 获取到所有View所以还是那个问题，如何获取到所有的View进行换肤处理；有一个点就是每个Activity都有setContentView方法，其实猜也能猜到，就是把xml布局解析成一个View对象；有点像AOP（面向切面编程）的思想，如果我们能从这个点切入，拿到每一个生成的View对象，我们就可以统一处理了； 那就是去看源码了，其实很简单，我的MainActivity继承至AppCompatActivity，跟着方法深入下去 12345@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... AppCompatActivity里面的方法，我们跟着layoutResID走，直到layoutResID变为View 1234@Overridepublic void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID);} AppCompatDelegate里面的抽象方法 1public abstract void setContentView(@LayoutRes int resId); AppCompatDelegateImpl里面的实现，其实看到LayoutInflater.from(mContext).inflate(resId, contentParent);这句代码就很熟悉了，我们也会经常使用它去加载布局； 123456789@Overridepublic void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();} 还是一样跟着resId走到LayoutInflater里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); } } 走到这个方法是返回生成的View，那生成View肯定是在inflate(parser, root, attachToRoot);方法里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 找到了生成View的地方 12// Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); 继续看createViewFromTag方法，里面使用各种Factory去创建View 1234567891011121314151617181920212223242526272829try { View view; if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { if (-1 == name.indexOf('.')) { view = onCreateView(parent, name, attrs); } else { view = createView(name, null, attrs); } } finally { mConstructorArgs[0] = lastContext; } } return view; 好的，就是这里了，因为所有加载xml布局创建View的流程都会走到这里来，然后Factory只是一个接口，到这里后从逻辑也可以看出来可能会有不同的Factory去创建View，也就是说不能再深入下去了；我们只需要实现我们的Factory然后设置给mFactory2就可以获取到所有的View了，这里是一个Hook点； 那么问题来了，我们怎么去实现用Factory创建View，这里xml里面的东西已经解析完了，看这个方法的参数，有了attrs和控件类名name，我们自己用反射不就轻松的可以生成View吗； 123View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { ... 还有有最简单的方法，其实系统原来已经实现了对吧，我们照着他写不就完事儿了吗；我们在这里打个断点，进入这个方法，他怎么实现我们就跟着写就完事儿了； 发现是在AppCompatDelegateImpl这个类实现的方法，好的直接看retur的地方，进去进入方法 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) { if (mAppCompatViewInflater == null) { TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); String viewInflaterClassName = a.getString(R.styleable.AppCompatTheme_viewInflaterClass); if ((viewInflaterClassName == null) || AppCompatViewInflater.class.getName().equals(viewInflaterClassName)) { // Either default class name or set explicitly to null. In both cases // create the base inflater (no reflection) mAppCompatViewInflater = new AppCompatViewInflater(); } else { try { Class viewInflaterClass = Class.forName(viewInflaterClassName); mAppCompatViewInflater = (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor() .newInstance(); } catch (Throwable t) { Log.i(TAG, &quot;Failed to instantiate custom view inflater &quot; + viewInflaterClassName + &quot;. Falling back to default.&quot;, t); mAppCompatViewInflater = new AppCompatViewInflater(); } } } boolean inheritContext = false; if (IS_PRE_LOLLIPOP) { inheritContext = (attrs instanceof XmlPullParser) // If we have a XmlPullParser, we can detect where we are in the layout ? ((XmlPullParser) attrs).getDepth() &gt; 1 // Otherwise we have to use the old heuristic : shouldInheritContext((ViewParent) parent); } return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); } 好的，终于看见最终的方法了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs, boolean inheritContext, boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) { final Context originalContext = context; // We can emulate Lollipop's android:theme attribute propagating down the view hierarchy // by using the parent's context if (inheritContext &amp;&amp; parent != null) { context = parent.getContext(); } if (readAndroidTheme || readAppTheme) { // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); } if (wrapContext) { context = TintContextWrapper.wrap(context); } View view = null; // We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) { case &quot;TextView&quot;: view = createTextView(context, attrs); verifyNotNull(view, name); break; case &quot;ImageView&quot;: view = createImageView(context, attrs); verifyNotNull(view, name); break; case &quot;Button&quot;: view = createButton(context, attrs); verifyNotNull(view, name); break; case &quot;EditText&quot;: view = createEditText(context, attrs); verifyNotNull(view, name); break; case &quot;Spinner&quot;: view = createSpinner(context, attrs); verifyNotNull(view, name); break; case &quot;ImageButton&quot;: view = createImageButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckBox&quot;: view = createCheckBox(context, attrs); verifyNotNull(view, name); break; case &quot;RadioButton&quot;: view = createRadioButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckedTextView&quot;: view = createCheckedTextView(context, attrs); verifyNotNull(view, name); break; case &quot;AutoCompleteTextView&quot;: view = createAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;MultiAutoCompleteTextView&quot;: view = createMultiAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;RatingBar&quot;: view = createRatingBar(context, attrs); verifyNotNull(view, name); break; case &quot;SeekBar&quot;: view = createSeekBar(context, attrs); verifyNotNull(view, name); break; default: // The fallback that allows extending class to take over view inflation // for other tags. Note that we don't check that the result is not-null. // That allows the custom inflater path to fall back on the default one // later in this method. view = createView(context, name, attrs); } if (view == null &amp;&amp; originalContext != context) { // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); } if (view != null) { // If we have created a view, check its android:onClick checkOnClickListener(view, attrs); } return view; } 仔细看的话，它创建出来的控件都是androidx.appcompat.widget里面的一些比较新的控件，就是升了一下级；其实感觉mFactory2就是Google自己修改皮肤用的； 如果我们的MainActivity继承至Activity的话，同样打断点会进入到另一个创建View的方法；虽然看起来代码很复杂，我们只要记住我们只是来创建View的，其他我们不管，我们自己实现的时候也是这个道理，我们就是实现创建View的方法；所以直接看创建View很简单了，就是直接用反射，传入View的参数AttributeSet，new一个View出来 12345...Object[] args = mConstructorArgs;args[1] = attrs;final View view = constructor.newInstance(args);... 这里还有个问题，既然这里可能有不同的Factory来创建View，我们随便实现一个，去设置给mFactory2，那肯定只会用我们的mFactory2来创建了；那是不是有问题，那我们的MainActivity其实继承Activity还是AppCompatActivity都会走我们自己的方法了；那我们的这个Factory到底是应该照着AppCompatActivity走的方法来写还是Activity走的这个方法来写，或者还有其他的方法来写 其实问题不大，正常开发中我们一般只会选一个Activity来做我们的BaseActivity是吧，我们就按照BaseActivity继承的这种类型来写；而且不同的Activity也可以，因为每个Activity的LayoutInflater是不一样的，我们可以实现不同的Factory分别设置给不同的Activity的LayoutInflater就行了； 好的在这里我们实现自己的Factory去创建View对象，就可以趁机保存所有的对象，然后当我们想换肤的时候就可以把每一个对象的属性修改就可以了；至于这里View怎么保存，怎么销毁，怎么防止内存泄漏这些小问题简单提一下，全局监听一下Activity的生命周期就完事了 1application.registerActivityLifecycleCallbacks(new SkinActivityLifecycleCallbacks()); 更换资源文件如何更换资源文件？插件化换肤感觉是最好的方法，通过一个皮肤包，可以理解为我们更换了一套皮肤后重新打的一个apk包；这样点击换肤的时候，我们拿到每一个View控件，获取到当前View对应属性的资源的ID，然后通过这个ID去皮肤包里面获取出对应的资源对象，然后设置给当前View就完成了换肤； 这里面有一个点，就是我们没法更换我们运行的APP里面的资源文件，我们只是从皮肤包里面读取出相应的资源，比如图片，就是读取出Drawable对象，通过setImageDrawable设置给当前的View； 具体如何去读取其实很简单，就是AssetManager通过反射设置apk文件的路径，就可以拿到Resources对象，Resources就可以通过resId拿到各种资源对象； 123456789AssetManager assetManager = AssetManager.class.newInstance(); Method method = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); method.setAccessible(true); method.invoke(assetManager, path); Resources resources = mApplication.getResources(); Resources skinRes = new Resources(assetManager, resources.getDisplayMetrics(), resources.getConfiguration()); //根据ID获取到资源文件Drawable drawable = skinRes.getDrawable(resId); 其实通过皮肤包来实现非常方便，不管是想内置几种皮肤还是上线后更新皮肤包都可以实现，而且不需要改动之前的代码； 整体流程总结一下，其实就是APP启动的时候，通过application.registerActivityLifecycleCallbacks();，监听Activity的生命周期；每个Activity启动的时候，获取Activity的布局加载器LayoutInflater，给它设置一个Factory，首先会用它去创建View，在创建的时候就会给View设置指定皮肤包里面的资源了；然后保存这个Activity里面的每一个View，当再次换肤的时候获取到每一个View，重新设置指定皮肤的资源；当然Activity销毁的时候肯定是要释放掉View的；大致的流程就是这样 缺点这个东西肯定是有缺点的，我们只是针对布局加载器LayoutInflater进行换肤，也就是说，只要是通过LayoutInflater创建的View我们都可以进行换肤；但是如果有些View是我们new出来的，是换不了的，解决方法也很简单，就是手动添加到换肤的View集合里面去； 第二是只换资源文件里面的属性，这没什么好说的，本来就是根据资源文件换肤； 第三就是和theme相关的控件颜色没法换，这个很简单，因为我们从皮肤包里面是获取不到theme对象的；其实获取到也没有办法，因为重新给Activity设置theme是必须重启Activity的；我自己各种看源码，各种反射搞了半天，发现这个东西的确是搞不定的，这个东西比较复杂，因为它不是一个具体的资源文件； 解决方法是在加载View的时候判断一下View，比如RadioButton或者TabLayout这种可以设置属性进去的就单独改改很简单，但是你要是涉及到那些只能跟随theme属性的控件比如Switch这种，那的确是换不了的，theme换不掉，没办法修改颜色； 1234567891011121314151617 if (view instanceof RadioButton) { if (isDrawable()) { RadioButton radioButton = (RadioButton) view; Drawable drawable = SkinResourcesUtils.getDrawable(attrValueRefId); radioButton.setButtonDrawable(drawable); } } if (view instanceof TabLayout) { TabLayout tl = (TabLayout) view; if (isColor()) { int color = SkinResourcesUtils.getColor(attrValueRefId); tl.setSelectedTabIndicatorColor(color); } } 只能说有相应的替代方案，做不到完美；包括自定义Factory也是一样的，包括自定义View也需要自己适配，换肤这种东西感觉没有一个万能的，完美的方案，只能是针对不同的项目有不同的解决方法； 其实还是不错了，有些问题虽然存在，但是实际项目中换肤应该都比较简单，随便写写，适配一下肯定没问题的； 项目地址：https://github.com/tyhjh/Skinpeeler","link":"/me/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/"}],"tags":[{"name":"日志","slug":"日志","link":"/me/tags/%E6%97%A5%E5%BF%97/"},{"name":"内存映射","slug":"内存映射","link":"/me/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"name":"插件化","slug":"插件化","link":"/me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"换肤","slug":"换肤","link":"/me/tags/%E6%8D%A2%E8%82%A4/"}],"categories":[{"name":"Android","slug":"Android","link":"/me/categories/Android/"}]}