{"pages":[],"posts":[{"title":"Android内存泄漏检测和定位","text":"建议阅读Android常见内存泄漏这篇文章，本文的例子来源于文章中的内存泄漏典型例子 内存泄漏检测工具Profiler其实Android studio自带的 Profiler 是不错的，可以很直观看到CPU、内存、网络的变化，但是有时候简单看看是看不出来内存泄漏的，需要知道具体怎么去分析 Android LeakCanaryAndroid LeakCanary易于集成，自动检测出内存泄漏，十分好用 使用Profiler以Android中的静态变量为例 1234567891011121314private static Activity sActivity;@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sActivity = this; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); } 程序是这样的，第一个Activity跳转到第二个Activity，然后finish()返回第一个Activity，我们反复多做几次；正常来讲第二个Activity会被销毁的，但是因为被静态变量引用了，所以应该是无法被回收的； 使用Profiler来查看内存泄漏首先是点击下面那一栏的Profiler按钮，可能还没有选择程序，点击+添加程序，这一步一般在我们操作程序前做，不然都没记录 会显示CPU、内存、网络和能耗四个东西，点进内存里面去看详情信息，其实只看内存的大致情况不能得出什么结论，感觉好像没什么问题 我们点击那个箭头符号（Dump Java heap），来捕获堆转储，堆转储显示在您捕获堆转储时您的应用中哪些对象正在使用内存，选择按包名排序 然后选择我们的程序，就可以看到哪些对象正在使用内存 看见Main2Activity还在内存中，证明它没有被回收掉，内存是发生了泄漏的，其中Main2Activity$1应该是表示Main2Activity里面的第一个匿名内部类对Main2Activity的引用，如果还有其他的匿名内部类，就是$2、$3这样排下去； Heap Dump 右边四列的意思分别如下，一般情况下，如果Shallow Size和Retained Size都非常小并且相等，都可以认为是已经被回收的对象。 Allocations：Java堆中的实例个数 Native Size：native层分配的内存大小。 Shallow Size：Java堆中分配实际大小 Retained Size：这个类的所有实例保留的内存总大小（并非实际大小） 点击Heap Dump中的Main2Activity对象，发现右侧出现了Instance View，再点击Instance View中的对象，出现Reference和上图一样；Reference显示对这个Main2Activity对象的引用，大部分都是系统层面的引用，可以看到第一个是sActivity这个静态变量的引用，就说明是它引起的内存泄漏； 还发现有很多this$0的引用，这个也往往是导致泄漏的原因，点进去查看发现最终还是sActivity的引用；而出现多个this$0是因为我反复操作了很多遍导致创建了很多个Main2Activity对象未被回收 在内存泄漏检查的过程中，我发现经常出现过理论上对象肯定是被回收了，却仍保留的情况。一般情况下，如果Shallow Size和Retained Size都非常小(比如我测试的一个空的activity，大概是270)并且相等，都可以认为是已经被回收的对象。因为系统已经不认为它会被用到，并且没有给它保留分配的内存。 使用Android LeakCanary这个东西特别简单，直接看官网就行了 就是GitHub地址：https://github.com/square/leakcanary 直接集成： 123456dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3' // Optional, if you use support library fragments: debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'} 直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情 12345678910111213public class ExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; } LeakCanary.install(this); // Normal app init code... }} 举个栗子以匿名内部类为例，操作流程和之前的例子一样；正常来讲调用了finish()方法，第二个Activity会被销毁的，但是因为使用了匿名内部类，所以sRunnable会持有Main2Activity的引用，而且sRunnable还是一个静态变量，所以会导致Main2Activity不会被回收掉 1234567891011121314151617181920212223public class Main2Activity extends AppCompatActivity { private static Thread sRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sRunnable = new Thread() { @Override public void run() { } }; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); }} 运行程序，然后过一会儿就会收到提醒，检测到了内存泄漏，打开看看；大概意思就是说sRunnable这个对象，它引用了Main2Activity，导致了内存泄漏；这个工具的确非常的简单友好了 参考文章： 使用 Memory Profiler 查看 Java 堆和内存分配 Android Profiler内存泄漏检查","link":"/2020/11/16/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%92%8C%E5%AE%9A%E4%BD%8D/"},{"title":"Android常见内存泄漏分析","text":"内存泄漏内存泄漏就是分配的内存空间没有及时回收导致的。可使用的内存变少，应用变卡，最后内存溢出后应用就会挂掉 内存泄漏的检测建议阅读Android内存泄漏检测和定位这篇文章，使用里面的检测方法可以轻松的验证本文中的内存泄漏例子 原因Android内存泄漏大多是因为Activity没有被回收导致的，Activity没有被回收一般分为两种情况 全局的static变量持有Activity的强引用 在Activity生命周期外的线程，持有Activity的强引用 引用类型推荐阅读Java中四种引用类型，感觉是非常容易理解的 静态变量类中定义了静态Activity变量，把当前的Activity赋值给静态变量，如果Activity生命周期结束的时候静态变量没有清空，就会导致内存泄漏。static变量是贯穿整个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被回收，同样的持有Activity（Context）的静态变量，比如View也是一样的道理 123456789101112131415private static Activity sActivity;@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sActivity = this; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); } 内部类非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是静态内部类却不会。 12345678910private static Test sTest; private static Test2 sTest2; class Test { } static class Test2 { } private void test() { sTest = new Test(); sTest2=new Test2(); } 1.如果这个非静态内部类实例内部做了一些耗时的操作，就会导致外围对象不会被回收，从而导致内存泄漏 12345678910111213141516171819protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); test(); }private void test() { new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); } 这个匿名内部类会引用这个Activity，内部开了线程做耗时操作，就会导致这个Activity不能被回收 2.结合上面的静态变量，如果静态变量持有非静态内部类的引用，而非静态内部类引用了该Activity，那就会导致这个Activity不能被回收 123456789101112private static Test sTest; class Test {} private void test() { sTest = new Test(); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); test(); } Test是非静态内部类，sTest是静态变量，注意这个静态变量是在onCreate中初始化的，会持有该Activity的引用，Activity被销毁的时候sTest不置空那么该Activity就无法被回收； 内部类常见情况上面都说了，非静态内部类会引用所属外部类，这时候如果创建一个内部类，而且持有一个静态变量的引用就容易会引起外部类没法被回收；同样的如果该内部类在子线程做了一些耗时操作，属于在Activity生命周期外的线程，也会导致外部类没法被回收；常见的情况有下面几种 Threads上面第一个例子已经写过了 TimerTask匿名内部类嘛，肯定就持有所在Activity的引用，又做耗时操作，肯定内存泄漏 Handler一个道理，匿名内部类嘛，肯定就持有所在Activity的引用，如果执行postDelayed的时候，Activity被销毁，那么Handler持有的Activity没法被回收，就内存泄漏了，而且里面也有一个匿名内部类Runnable持有Activity 1234567891011new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }.postDelayed(new Runnable() { @Override public void run() { } },10000); 系统服务这个也很好理解，当你使用系统服务的时候，可以注册监听器，会导致服务持有Context的引用，如果在Activity销毁的时候，没有注销掉监听器，就会导致内存泄漏； 1234//传感器的监听器注册SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST); 注册广播接收器也是需要在onDestroy方法里面注销 资源未释放这个简单，一般就各种流、各种资源没有关闭，集合中对象没清理导致，倒是不容易犯错 静态内部类解决内存泄漏1.静态内部类不会持有外部类的引用，所以使用静态内部类可以解决以上问题，如果静态内部类里面需要引用外部类，可以通过弱引用的方式来引用；2.用static的变量引用匿名内部类的实例或将匿名内部类的实例化操作放到外部类的静态方法中 123456789101112131415161718192021222324252627282930//静态内部类private static class Myhandler extends Handler { private final WeakReference&lt;Activity&gt; mActivity; public Myhandler(Activity activity) { mActivity = new WeakReference&lt;Activity&gt;(activity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); Activity activity = mActivity.get(); // ... } } private final Myhandler mMyhandler=new Myhandler(this);//这样写不会持有外部类的引用private static final Runnable sRunnable = new Runnable() { @Override public void run() { /* ... */ } };@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMyhandler.postDelayed(sRunnable, 1000 * 60 * 10); } 方法没有问题，但是为什么上面的写法sRunnable没有引用外部类而下面的写法会引用呢，会导致内存泄漏呢；我觉得是因为初始化的位置不同，静态变量和静态类先被初始化了，所以没有外部类的引用；感觉是这样的吧 12345678910private static Runnable sRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sRunnable = new Runnable() { @Override public void run() { /* ... */ } }; } 参考文章： [译]Android内存泄漏的八种可能（上） 记一次Android内存泄漏的优化经历 Android 内存泄漏分析心得","link":"/2020/11/16/Android%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/"},{"title":"双十一领喵币","text":"领喵币领喵币又开始了，使用Android的辅助功能可以实现自动领喵币的功能；具体的效果可以下载下面的apk体验 Apk地址：https://github.com/tyhjh/TmallCoin/raw/master/%E5%8F%AF%E8%BF%90%E8%A1%8Capk/%E9%A2%86%E5%96%B5%E5%B8%81.apk备用地址：http://share.tyhjh.com/share/TmallCoin.apk 功能要做的功能就是自动点击按钮，完成这些只需要等待15秒就可以完成的任务；去年领喵币还比较简单，按钮的位置和功能都是固定的，只需要截图，然后判断固定位置的按钮的颜色是红色还是已完成的灰色，就可以点击按钮去另一个界面等待15秒后再返回，缺点就是只能适配一个分辨率的手机，并且今年按钮的位置不是固定的，我们需要区分哪些是可以通过脚本完成的，哪些是通过简单的脚本无法完成的 思路具体的思路是后台开启服务（AccessibilityService），提供一个悬浮窗按钮，进入到领喵币中心以后，点击按钮开始对屏幕进行截屏；通过图像识别识别出按钮上的文字及位置，通过文字判断当前的任务是否是简单浏览就可以完成的，比如去浏览、去逛逛，去搜索等为简单操作，使用Android辅助功能进行模拟点击该位置，然后等待15秒后即可完成，然后再返回继续进行识别；但是比如去完成这样的按钮一般都是比较复杂的，难以通过脚本完成，需要避开；但是也可能去完成按钮的任务也是一个比较简单的浏览的任务，就需要一些技巧去判断； Android辅助功能建议阅读：https://www.jianshu.com/p/8935bde74c50 具体实现在辅助服务（AccessibilityService）里面，开启线程循环截图进行图像识别，识别出所有的文字及位置；OcrResult类为识别出来的结果，包含文字结果和所在位置；文字识别使用的框架是PaddleOCR，也可以通过jitpack库进行引入这个封装的库，可以看实现的源码：https://github.com/tyhjh/WordsFind 1implementation 'com.github.tyhjh:WordsFind:v1.0.3' 第一次识别会对屏幕右方按钮部分的图像进行裁剪和识别，可以识别出大多数简单的操作由脚本去执行；但是有部分操作按钮显示为去完成，实际也是浏览任务的，在按钮的左侧有文字进行说明一般也是带有浏览、逛逛等文字，就需要在按钮部分识别完成并且未找到可执行的任务时，再次对全图进行查找，如果查找到匹配的文字就进行点击； 123456789101112131415//获取屏幕截屏Bitmap bitmap = ScreenShotUtil.getInstance().getScreenShot();//裁剪出识别区域，只识别按钮Bitmap wordsBitmap = Bitmap.createBitmap(bitmap, startX, startY, (int) ((1 - START_X_SCALE) * width), (int) ((1 - START_Y_SCALE) * height));//获取文字所在的区域List&lt;OcrResult&gt; rectList = WordsFindManager.getInstance().runModel(wordsBitmap);//遍历文字找到按钮进行点击boolean isFindTxt = findBtn(rectList);//还是没有可以点击的文字，识别全图if (!isFindTxt) { //获取文字所在的区域 rectList = WordsFindManager.getInstance().runModel(bitmap); //继续遍历文字进行点击 boolean notFinished = findBtn(rectList); } findBtn方法就是通过识别到的文字判断该任务是否可以执行，如果可以执行就进行点击； 12345678910111213141516171819202122232425private static final List&lt;String&gt; btnTexts = Arrays.asList(new String[]{&quot;去浏览&quot;, &quot;去逛逛&quot;, &quot;去搜索&quot;, &quot;去观看&quot;});private boolean findBtn(List&lt;OcrResult&gt; rectList) { //识别到去浏览的按钮 for (OcrResult result : rectList) { //获取识别的文字 String txt = result.getTxt(); //如果文字为可数组里面的文字，表示可以点击 if (btnTexts.contains(txt)) { //获取喵币 getCatCoin(startX, startY, result); return true; } //任务描述的文字处理，有字代表任务可以点 if (txt.contains(&quot;浏览&quot;) || txt.contains(&quot;逛一逛&quot;)) { //判断该任务是不是已完成的任务 if (notFinished(result)) { //获取喵币 getCatCoin(startX, startY, result); return true; } } } return false; } 获取喵币的代码还是比较简单的，就是点击按钮进入浏览的界面，然后等15秒就返回；因为淘宝页面加载等原因，等待的时间大于15秒才能完成任务 123456//点击去浏览clickOnScreen(rect.left + startX, rect.top + startY, 10, null);//等待页面加载3秒+浏览18秒SystemClock.sleep(22 * 1000);//返回performBackClick(); 还有个问题如果文字不是在按钮上识别出来的，比如任务的描述文字包含浏览，但是其实这个任务其实已经完成了，如果识别不到这种情况就会一直点击该任务，所以会保存识别出的已完成文字位置，通过对比识别出来的描述文字浏览和已完成文字的Y坐标，判断是不是同一个任务，判断该任务是否已经完成 12345678for (Rect rect : rectListFinished) { //计算两个文字的顶部的距离 int value = Math.abs(rect.top - result.getRect().top); //如果大于70像素，判断不是一个任务，该任务未被执行过 if (value &lt; 70) { return false; }} 其中录屏截图框架使用的是：https://github.com/tyhjh/ScreenShot，也可以通过jitpack库进行引入 1implementation 'com.github.tyhjh:ScreenShot:v1.0.2' 思路还是比较清晰的，图像识别找可以浏览完成的任务，定时浏览完成任务；代码也比较的简单，示例代码有所删减，详细的实现可以看源码； 项目地址：https://github.com/tyhjh/TmallCoin","link":"/2020/11/16/%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A2%86%E5%96%B5%E5%B8%81/"},{"title":"用自己电脑搭建公网可访问的服务器","text":"原文链接：https://www.jianshu.com/p/3c43afeb9cb1 IP地址今天突然想到一个存在很久的疑问，服务器和普通电脑有什么不同呢？在我看来最大的区别就是服务器有固定的IP，自己电脑的IP是变化。 就我们寝室来讲，首先你在Windows上面获取的192.168.xx.xx这个是本地IP，是路由器分配的，连到同一个路由器上的电脑可以通过这个来访问（同一个局域网内）其他电脑，前提是访问的电脑提供了服务，同理，在同一个局域网内，把一台电脑作为服务器，其他电脑根据IP来访问是没问题的（有时候电脑开启了防火墙也会访问不到，关了就好了）。 那么外网怎么访问呢？首先PC的外网IP是变化，但是一般不重启路由器什么的，不会经常变化。通过这个网站我们可以看到电脑当前的外网IP。而且，你会发现同一个路由器下面的电脑外网IP都是一样的。 通过IP访问自己电脑那通过这个外网IP能不能访问到自己电脑呢，其实没有这样简单。首先，这个外网IP可以算作是路由器的IP，所以意思就是只能访问到路由器，想要访问到路由器下的电脑上，那么要进行端口映射。端口映射很简单，路由器基本自带的功能，路由器设置一下，比如你的电脑本地IP是192.168.31.198（可以在路由器设置固定地址），你的程序端口是8080，那么添加一条端口映射规则，外部、内部端口设置8080，内部IP设置192.168.31.198，就可以了。或者开启DMZ，开启DMZ功能可以将内网某一个设备的IP映射到外网，方便从外网访问到该设备，就是相当于把这个设备当做路由器一样，外网可以直接访问。 使用域名访问那理论上这样做外网是可以访问自己的电脑了，但是作为服务器，你的IP始终在变化，那没法用。比如APP，可以想一些办法，比如IP变了，我们下发通知APP相应改变，但是服务器IP都变了，APP根本没法连接服务器，就无法更改内容；可以把IP存在其他服务器上，自己电脑IP变了，就发送到其他服务器，APP每次都从其他服务器先获取IP，这样有点麻烦了，还需要其他服务器。 其实有很多软件可以做到这件事包括我听的有点多的花生壳，但是收费，不收费就限制你的流量什么的，算了我还是不用了。但是它的解决方案比较有意思，它是卖一个域名给你，通过动态解析域名来实现。具体就是，域名需要解析到一个公网IP才能使用，使用方法和IP地址没什么两样就是好记。当IP改变的时候我重新解析域名到新的IP地址，那不管外网IP怎么变我的域名永远是指向我的电脑的外网IP的，可以通过域名来访问我们的电脑 域名动态解析动态解析叫DDNS，域名不贵，我在阿里云买了两个，一年50块，我网上查了一下，阿里是有API调用来解析域名的，看看文档，申请APPKey什么的。然后下载它的SDK，运行，非常棒，写个程序，隔几分钟获取一次电脑的外网IP，然后获取阿里的解析记录的IP，一样则证明IP没有变，不处理，不一样说明IP变了，重新设置解析，DDNS完事。SDK好像没文档，看看示例代码能猜出用法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static IAcsClient client = null; String regionId = &quot;cn-hangzhou&quot;; //必填固定值，必须为“cn-hanghou” String accessKeyId = &quot;xxxxxxx&quot;; // your accessKey String accessKeySecret = &quot;xxxxxxx&quot;;// your accessSecret public void updateDns() { IClientProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); client = new DefaultAcsClient(profile); DescribeSubDomainRecordsRequest recordsRequest = new DescribeSubDomainRecordsRequest(); recordsRequest.setSubDomain(&quot;one.yorhp.com&quot;);//设置域名 DescribeSubDomainRecordsResponse recordsResponse; //request.setProtocol(ProtocolType.HTTPS); //指定访问协议 //request.setAcceptFormat(FormatType.JSON); //指定api返回格式 //request.setMethod(MethodType.POST); //指定请求方法 //request.setRegionId(&quot;cn-hangzhou&quot;);//指定要访问的Region,仅对当前请求生效，不改变client的默认设置。 try { recordsResponse = client.getAcsResponse(recordsRequest); List&lt;DescribeSubDomainRecordsResponse.Record&gt; recordList = recordsResponse.getDomainRecords(); for (DescribeSubDomainRecordsResponse.Record record : recordList) { String oldIp = record.getValue(); String outter_ip = IpAddress.getV4IP(); if (!oldIp.equals(outter_ip)) { UpdateDomainRecordRequest udr_req = new UpdateDomainRecordRequest(); udr_req.setRecordId(record.getRecordId()); udr_req.setRR(record.getRR()); udr_req.setValue(outter_ip); udr_req.setType(record.getType()); udr_req.setTTL(record.getTTL()); udr_req.setPriority(record.getPriority()); udr_req.setLine(record.getLine()); UpdateDomainRecordResponse udr_resp = new UpdateDomainRecordResponse(); udr_resp = client.getAcsResponse(udr_req); System.out.println(&quot;重新解析域名成功：&quot;+outter_ip); } else { System.out.println(&quot;域名未改变：&quot;+outter_ip); } } } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } 其中还有个解析生效时间的问题，阿里上一般是10分钟，也就是说你的电脑作为服务器可能会崩溃10分钟，那不好。可以升级一下解析，好像是买一次就好了，我将近600天，50块，每次解析1秒生效。这样纸搞，理论上讲，你就具备把一台电脑作为服务器的技术了，我感觉还是很有用的。 Java获取IP地址通过下面的代码可以获取外网IP，应该就是通过访问另一个服务器上的接口来获取自己的IP地址，然后再返给我们，有个问题是&quot;http://ip.chinaz.com&quot;这个接口是别人的，随时可能会被关掉，所以需要在网上找找其他方法，原理应该都是一样的，只是返回数据不同，解析方式不同而已 123456789101112131415161718192021222324252627282930313233343536373839404142//获取外网IPpublic static String getV4IP() { String ip = &quot;&quot;; String chinaz = &quot;http://ip.chinaz.com&quot;; StringBuilder inputLine = new StringBuilder(); String read = &quot;&quot;; URL url = null; HttpURLConnection urlConnection = null; BufferedReader in = null; try { url = new URL(chinaz); urlConnection = (HttpURLConnection) url.openConnection(); in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), &quot;UTF-8&quot;)); while ((read = in.readLine()) != null) { inputLine.append(read + &quot;\\r\\n&quot;); } //System.out.println(inputLine.toString()); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (in != null) { try { in.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } Pattern p = Pattern.compile(&quot;\\\\&lt;dd class\\\\=\\&quot;fz24\\&quot;&gt;(.*?)\\\\&lt;\\\\/dd&gt;&quot;); Matcher m = p.matcher(inputLine.toString()); if (m.find()) { String ipstr = m.group(1); ip = ipstr; } return ip; } 运营商分配IP但是，事情没有这样简单，这么流行收费软件是有原因的。我做完上面的步骤还是不行，外网还是没办法访问服务器，我检查了很久，发现路由器显示的IP和我获取到的外网IP不一样，理论上都应该是外网IP，应该一样的。用代码获取到的IP肯定是外网IP，那路由器上显示的IP就不是外网IP，我百度了一下： 1234567如果你在路由器中查看到的WAN口IP地址，和外网的IP地址不一样。这种情况是宽带运营商，给你分配的一个内网IP地址；即你路由器WAN口IP地址是一个内网IP地址，很多个宽带用户，共同使用一个外网IP地址上网。之所以出现宽带运营商，给大家分配内网IP地址，让多个宽带账号共享一个外网IP地址上网，应该是IPv4地址不够用的原因。所以，宽带运营商才会才去这种措施，让多个用户共享一个外网IP地址。这情况实际上和我们自己使用路由器上网一样的，我们电脑、手机上获取的是路由器分配的一个内网IP地址，最总多台电脑、手机共同使用路由器中的WAN口IP地址上网。一般来说，WAN口IP和外网IP地址不一样，并不会影响到我们的正常上网；不过在一些特殊网络环境下，会影响到用户的正常使用。例如在路由器中设置端口映射的时候，由于路由器的WAN口和外网IP地址不一样，会导致端口映射失败。 看到没有，有这种情况，就是你的路由器本来就不是用的外网IP，相当于在你的路由器上面还有一个路由器，而且我们没法在那里设置端口映射。有人说可以打电话叫服务商给你换一个外网IP，我感觉我学校是没什么可能，我也没试过，我感觉家里或者公司应该可以。 就是说如果你去刚才那个网站看了你的公网IP如果和你的路由器主界面设置账号那里显示的IP一样的，那好恭喜你，上面那样搞没问题，很简单，也非常好，你想想，阿里一个1G，1核，带宽1M的服务器都是59一个月，你自己电脑带宽100M，性能也好，多好，还免费。所以我有兴趣来搞这个东西。 其他方法那搞了一天白搞了？那不可能，可以看出来之前那个办法已经没有办法实现了，真的是没有办法直接访问自己的电脑了，那还有另一种说法，端口映射内网穿透。这篇文章写的很详细了，端口映射内网穿透方案探索。 其实呢，我看了一下，方法基本上就是通过一些服务来转发请求吧，大概就是你的电脑一直连接另一个服务器，当另一个服务器有一些特定的请求的时候转发给你的电脑，基本道理我觉得是这样吧。那其实和之前那个方法真的是天壤之别了。速度肯定取决于这两台服务器中最慢的一台了，反正感觉没什么优势。 我现在实现了最简单的使用ssh端口转发来做内网穿透。因为非常简单，我试了一下。按照这篇文章使用ssh端口转发来做内网穿透 ,要下载一个xshell软件，免费的。这样的确可以映射成功，但是真的垃圾，玩玩做个网站什么的可以，作为什么文件服务器那不用想了，我写了个下载文件的接口，xshell直接崩了。 1centos7重启ssh服务的命令为 service sshd restart IPV6那其实可以看到，我们的电脑没有固定的IP，服务商甚至都不给我们外网IP，其实我们去找服务商买一个固定的IP，那这个连接的电脑就可以当做服务器使用了。 现在的大部分技术是IPV4，所以静态IP稀缺，导致需要付费使用静态IP，在以后IPV6的使用，几乎可以让地球上每一个人都有一个属于自己的静态IP。 在杭州办了电信宽带，发现有外网IP，直接映射一下的确成功了；祝大家也能成功 总结重点就在于你的宽带账户有没有被分配公网IP，有的话，公网IP就相当于被设置在了你家接入网线的第一个路由器或者猫上面；谁都可以访问这个公网IP，设置一下端口映射就可以把相应端口的访问请求转发到这个路由器下的电脑上，电脑自己来做处理，自己电脑就相当于一台服务器了。有些路由器是Linux系统的，安装一些硬盘什么的可以直接就作为服务器了，都不需要再映射","link":"/2020/11/16/%E7%94%A8%E8%87%AA%E5%B7%B1%E7%94%B5%E8%84%91%E6%90%AD%E5%BB%BA%E5%A4%96%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"Android日志工具的设计","text":"日志工具日志工具是日常开发中必不可少的工具，日志工具的功能一方面是开发时的实时打印，用于进行调试；另一个方面就是输出日志文件，当程序运行出现异常的时候用于定位问题；之前在项目中负责了日志工具的开发工作，最近也有同事咨询日志性能相关的东西，感觉还是有些技巧可以总结一波的。 日志打印功能基本打印对于日志打印，Android提供了Log类用于日志打印，打印日志分不同的等级，便于日志工具的封装，一般使用带日志等级的方法进行打印，而不是直接调用相应等级的方法；其中需要注意的一点是当tag参数TextUtils.isEmpty()时，是不会进行打印输出的； 1234567891011/** * Low-level logging call. * @param priority The priority/type of this log message 日志等级 * @param tag Used to identify the source of a log message. It usually identifies TAG * the class or activity where the log call occurs. * @param msg The message you would like logged. 打印的信息 * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } 打印优化控制台打印出日志后，再根据日志找出打印的位置，代码比较多的时候还是比较耗时的，可以进行模仿AndroidStudio的Exception的打印，点击打印的时候就可以跳转到代码所对应的地方；点击跳转的日志打印固定格式如下 1&quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot;+ targetStackTrace.getLineNumber() + &quot;)&quot; 除此以外，还可以把当前线程和方法名打印出来 12345678910111213141516171819202122232425262728293031/** * 获取日志出处 * * @return */ private static String getTargetStackTraceElement() { StackTraceElement targetStackTrace = null; boolean shouldTrace = false; //获取线程堆栈转储的堆栈跟踪元素数组 StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); //遍历元素数组 for (StackTraceElement stackTraceElement : stackTrace) { //该对象是否是打印日志自身 boolean isLogMethod = stackTraceElement.getClassName().equals(LogUtils.class.getName()); //如果上一个对象是日志工具本身并且该对象不是则证明该对象就是使用日志工具的类 if (shouldTrace &amp;&amp; !isLogMethod) { //保存调用日志工具的对象 targetStackTrace = stackTraceElement; break; } //保存上一个对象是不是打印工具本身 shouldTrace = isLogMethod; } //获取线程名 String tName = Thread.currentThread().getName(); //获取调用日志工具执行的方法 String methodName = targetStackTrace.getMethodName(); //进行拼接 return tName + &quot; -&gt; &quot; + methodName + &quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot; + targetStackTrace.getLineNumber() + &quot;)&quot;; } 也可以在一次打印前后加上一些分割线，这样看起来会更直观、更易用；打印效果如下 具体实现是在进行日志打印的时候拿到线程堆栈转储的堆栈跟踪元素数组，这里面的信息是当前线程的堆栈信息；我们可以对比一下系统的异常输出日志，一般有异常抛出e.printStackTrace会全部输出到控制台，如下图所示；可以看出来第一个输出的是异常抛出的方法，之后都是上级的方法；同理我们获取到线程的堆栈信息后只想打印一下调用日志工具的地方的信息，就需要从这个stackTrace数组里面去找，取第一个的话肯定是日志工具类本身的方法，不是我们想要的，所以代码里面进行了判断，找第一个不是日志工具类的对象就好了；其实这里也可以根据代码直接写死取第几个对象，因为调用日志工具类的方法后执行的方法个数肯定是固定的； 除此以外还可以对特殊格式的字符串进行打印的优化，比如说提供对Json数据进行格式化打印的方法，这个看起来会很方便；具体的实现就是做一些简单的字符替换，网上一大堆这里就不再给出代码； 输入日志到文件输出日志到文件还是比较简单的，只需要开启一个输出流，将打印的日志输出到日志文件中即可； 12345678910111213/** * 写日志到文件，示例简化代码 * @param logMsg */ private void writeLogFile(String logMsg){ FileOutputStream fos = null; String logFilePath =&quot;sdcard/log.txt&quot;; File file = new File(logFilePath); fos = new FileOutputStream(file, true); fos.write(logMsg.getBytes()); //关闭流 fos.close(); } 多线程调用但是如果只是这样实现的话肯定是有问题的，写文件操作肯定是需要考虑性能的，每执行一次方法就会开启一个输出流，会对性能造成很大的影响，很容易出现内存溢出；因此只能开启一个输出流，可以将输出流设置为成员变量每次执行完以后不关闭，APP退出时再进行关闭；但是对于多线程调用，多个线程同时进行写文件操作也可能会出现问题，可以通过synchronized加锁来实现同步； 12345678910111213141516/** * 文件输出流 */ private FileOutputStream mOutputStream; /** * 写日志到文件，示例简化代码 * @param msg */ private synchronized void writeLogFile(String msg){ if(mOutputStream==null){ mOutputStream=new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); } mOutputStream.write(msg.getBytes()); mOutputStream.flush(); } 建立写入缓存区当日志频繁打印的时候，每次打印一行，会不停的执行文件写入操作，效率比较低，会对性能造成一定的影响；可以使用带缓冲区的输出流BufferedOutputStream设置一定的内存缓冲区大小，先把日志数据先写入缓冲区，等缓冲区满了，再把数据写到文件里，能够大量减少 IO 次数，提高效率；但是也是有缺点的，缓冲区设置的越大越能减少IO次数，但是当程序异常退出的时候缓冲区的日志就会丢失掉，设置越大，丢失的越多；下面会讲讲优化方法 123456789101112131415161718/** * 带缓冲区的输出流 */private BufferedOutputStream mOutputStream;/** * 写日志到文件，示例简化代码 * * @param msg */private synchronized void writeLogFile(String msg) { if (mOutputStream == null) { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); mOutputStream = new BufferedOutputStream(fileOutputStream,BUFF_SIZE); } byte[] bytes = msg.getBytes(); mOutputStream.write(bytes,0,bytes.length);} 线程优化写入日志到文件的操作是在子线程进行操作的，在执行加了锁后的方法writeLogFile是内部私有的方法，我们需要对外提供一个方法，因为写文件是个耗时操作，所以这个方法是需要在子线程执行，这时候肯定就会使用线程池；使用线程池就会有线程的创建和回收，日志打印频繁也会对性能造成一定的影响；可以创建一个独立的线程进行写入日志到文件的操作，创建一个缓存区，对外部提供的方法将日志都放在缓冲区里面，线程里面循环从缓存区里面去读出日志，写入到文件中；这个缓存区可以使用一个数组或集合来实现，只要保证读写和删除的效率高即可； 12345678910111213141516171819202122232425262728293031/** * 初始化日志工具，示例简化代码 */ public void init() { openWrite = true; new Thread(new Runnable() { @Override public void run() { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); BufferedOutputStream mOutputStream = new BufferedOutputStream(fileOutputStream, BUFF_SIZE); while (openWrite) { if (msgCache.size() &gt; 0) { byte[] bytes=msgCache.get(0).getBytes(); mOutputStream.write(bytes,0,bytes.length); msgCache.remove(0); } } } }).start(); } /** * 将日志存入缓存区 * * @param msg */ public void writeLogFile(String msg) { if (msgCache.size() &lt; LOG_MSG_CACHE_SIZE) { msgCache.add(msg); } } 这里对于msgCache这个集合也做了大小限制，因为极端情况，如果一直添加日志字符串到集合里面也会造成内存溢出，所以可以设置一下集合的大小控制一下，对于溢出的日志会被舍弃，也算是一个异常处理；讲道理一般情况是不可能出现的，如果出现了不做处理程序的性能肯定也会出问题。做一下计算如果每条日志是20个汉字，就是60个字节，如果缓存区设置为1M的话，也是可以缓存2万多条日志了； 日志缓存区优化感觉上面的做法还是不是特别靠谱，虽然很少几率发生，但是毕竟丢弃日志还是不太友好的；这里可以通过阻塞队列ArrayBlockingQueue代替普通的集合进行存储，初始化的时候需要指定队列的大小，当队列满了的时候会阻塞处理直到队列有空间，就不会主动进行日志的丢弃； 1private ArrayBlockingQueue&lt;String&gt; mCacheLog = new ArrayBlockingQueue(2000); 日志文件压缩日志多了以后日志文件的清理肯定是必要的，不然随着运行时间的延长日志文件会无限大；那么为了保存更多、更久的日志就可以对日志文件进行压缩，Android自带的压缩可以节省大约10以上倍的存储空间 12345678910111213//简写代码//压缩后保存的文件的输出流FileOutputStream fos = new FileOutputStream(zipFile);ZipOutputStream zos = new ZipOutputStream(fos);//原日志文件的输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));ZipEntry entry = new ZipEntry(&quot;&quot; + file.getName());zos.putNextEntry(entry);int count;byte[] buf = new byte[1024];while ((count = bis.read(buf)) != -1) { zos.write(buf, 0, count);} 内存映射文件上面只是一个非常普通的日志工具的实现，由于设置了缓冲区，当APP异常退出的时候就会导致日志的丢失；而且无论怎样优化还是避免不了文件的IO操作，这不是废话吗，功能就是写日志到文件，肯定避免不了； 其实还是有办法进行优化，就是mmap（一种内存映射文件的方法），即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系，函数原型如下 1void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 mmap 的回写时机 内存不足 进程退出 调用 msync 或者 munmap 不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD) 这篇文章介绍的非常不错 Android-内存映射mmap 简单点就是说，mmap操作提供了一种机制，可以让用户程序对内核空间的文件进行读写操作，这种机制不需要再将文件数据从内核空间读写到用户空间，相较于普通的文件读写，减少了一次数据的拷贝，效率更高；而且在内存不足或者进程退出的时候，会将数据写入文件，避免日志丢失的情况； 具体实现可以在C++里面使用mmap函数来实现，就是上面那个函数原型；不过在Java中也提供了内存映射的实现，就是MappedByteBuffer；先看看MappedByteBuffer的用法 1234567RandomAccessFile raf = new RandomAccessFile(sFile, &quot;rw&quot;);raf = new RandomAccessFile(sFile, &quot;rw&quot;);//把文件从0开始到FILE_SIZE映射到内存中MappedByteBuffer mByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, FILE_SIZE);byte[] msgbyte = msg.getBytes();//写入内容mByteBuffer.put(msgbyte); 可以把文件映射到内存中，获取到一个MappedByteBuffer对象，往这里面put数据就会写入到文件中；那么第一个问题，这个FILE_SIZE设置多大生成的日志文件就是多大；设置太大了，在日志没达到这个大小的时候应用退出，就浪费了，尤其是应用异常退出的时候，根本没机会对日志文件进行处理；设置小了，当日志文件达到这个大小的时候需要进行扩展，重新进行映射，这样的操作频繁了就会影响性能； 方案比较测试数据 15byte的日志执行10万次，也就是写入1.43M数据到文件 方案 耗时/ms 普通文件输出流耗时 16756 缓冲区大小为默认大小(8192)的输出流耗时 977 设置内存映射文件，初始映射大小为1M时耗时 1151 冷静分析就时间消耗来看，设置输出流缓冲区和内存映射性能差不多，比普通的输出流效率高了很多；讲道理，不应该是mmap这种黑科技应该要厉害一点吗？我原本也是这样认为的，毕竟内存映射那一大堆不太能懂的描述看起来很厉害的样子。但是我们可以冷静分析一波，具体原理可以看上面那篇Android-内存映射mmap的文章； 这里简单点讲，普通读写文件（就是输入输出流的write和read等操作）是将硬盘的文件加载到内核空间，再复制到用户空间，用户才获取到数据，复制了两遍（这个顺序是从硬盘读文件，反之则是写文件）；而mmap内存映射就是只需要将文件从硬盘加载到内核空间，只复制一次用户就可以拿到数据；所以mmap优势在于少复制一次；但是对于BufferedOutputStream呢，虽然写一次文件需要复制两次，效率低，但是好在我有缓存区呀，我是大大减少了写入的次数；单次写入效率低的问题，就被减小了呀；而再反观mmap虽然你写入的效率极高，但是你没有缓存区，写入的次数毕竟多呀；所以缓存区这个减少写入文件次数的对于效率的提升作用是非常大的，从测试耗时来看设置默认大小的缓存区对性能的提提升有17倍左右； 所以如果给mmap加一个缓冲区，性能肯定会更高，但是加了缓冲区，应用异常退出，日志就可能丢失；鱼和熊掌不可得兼，其实感觉mmap够了，效率够高又能防止日志丢失，好好写写MappedByteBuffer的使用的逻辑还是很不错的。 总结基本上这样的话日志工具应该就差不多能用了，具体实现逻辑的话还是要自己去实现，这里也只是谈到自己遇到的一些可以优化的点，感觉上还是比较简单的。","link":"/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"Android仿网易云鲸云音效动效","text":"最近网易云音乐出了一个叫鲸云音效东西，效果还不错，播放界面还带了动效，这个就比较炫酷了，感觉比较有意思，所以也想自己做一个，其中一个我觉得比较好看的效果如下（动图的来源也比较有意思，后面会讲）… 具体思路首先自定义布局是了解的，可能会用到surfaceView去绘制，整个动画可以分为四个部分，第一个是旋转的图片，这个好说；第二个是运动并且透明度渐变的三角形，这个画画也简单；第三个是根据音乐变化而变化的一个曲线吧，这个可能比较难，我也没接触过，不过可以试试看，第四个是模糊的背景，这个简单。 具体实现实现模糊的背景这个倒是简单，之前也用过一个模糊背景的工具还不错，不过存在一个问题，我是打算自定义一个surfaceView，给surfaceView画一个背景倒是不难，也遇到两个问题 1.怎么将图片以类似自动裁剪居中的方式画上去，这个想想其实简单，取得画布的大小和bitmap的大小，满足一边进行缩放，裁剪掉多余部分就好了 12345678910111213141516171819202122/** * 裁剪图片 * * @param rectBitmap * @param rectSurface */ public static void centerCrop(Rect rectBitmap, Rect rectSurface) { int verticalTimes = rectBitmap.height() / rectSurface.height(); int horizontalTimes = rectBitmap.width() / rectSurface.width(); if (verticalTimes &gt; horizontalTimes) { rectBitmap.left = 0; rectBitmap.right = rectBitmap.right; rectBitmap.top = (rectBitmap.height() - (rectSurface.height() * rectBitmap.width() / rectSurface.width())) / 2; rectBitmap.bottom = rectBitmap.bottom - rectBitmap.top; } else { rectBitmap.top = 0; rectBitmap.bottom = rectBitmap.bottom; rectBitmap.left = (rectBitmap.width() - (rectSurface.width() * rectBitmap.height() / rectSurface.height())) / 2; rectBitmap.right = rectBitmap.right - rectBitmap.left; } } 2.由于我后面画三角形必须得不停地刷新，背景需要重复绘制，感觉有点浪费资源，看了一下局部刷新什么的感觉没什么用，所以就直接先设置为父布局的普通的背景好了，再将surfaceView设置为透明 123456@Overridepublic void surfaceCreated(SurfaceHolder surfaceHolder) { setZOrderOnTop(true); getHolder().setFormat(PixelFormat.TRANSLUCENT);} Android图片模糊的工具类:https://www.jianshu.com/p/c676fc51f3ef 实现旋转的图片这个更简单，为了方便也是直接使用一个ImageView，通过自带的视图裁剪工具剪裁为圆形，然后通过属性动画来旋转 设置一直旋转的属性动画 123456objectAnimator = ObjectAnimator.ofFloat(ivShowPic, &quot;rotation&quot;, 0f, 360f);objectAnimator.setDuration(20 * 1000);objectAnimator.setRepeatMode(ValueAnimator.RESTART);objectAnimator.setInterpolator(new LinearInterpolator());objectAnimator.setRepeatCount(-1);objectAnimator.start(); 视图裁剪 1234567891011121314151617/** * 设置裁剪为圆形 * * @param view * @param pading 这个是设置间距是长或宽的几分之一 */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public static void setCircleShape(View view, final int pading) { view.setClipToOutline(true); view.setOutlineProvider(new ViewOutlineProvider() { @Override public void getOutline(View view, Outline outline) { int margin = Math.min(view.getWidth(), view.getHeight()) / pading; outline.setOval(margin, margin, view.getWidth() - margin, view.getHeight() - margin); } }); } 实现运动的三角形为了保证性能，这个就得使用surfaceView来做了；大体思路就是随机生成一些三角形，三角形速度大小一样，方向随机，从圆中心向外移动，移动过程将透明度减小到零 三角形有速度不过速度大小都一样就先不用管，有速度方向用角度来代替，也好计算运动后的位置，有三个顶点坐标。 所以三角形的初步定义 12345678910111213public class Triangle { public Point topPoint1, topPoint2, topPoint3; public int moveAngle; public Triangle(Point topPoint1, Point topPoint2, Point topPoint3) { this.topPoint1 = topPoint1; this.topPoint2 = topPoint2; this.topPoint3 = topPoint3; moveAngle = getMoveAngel(); }} 随机生成了三角形简单的方法，就是先指定一个坐标区域比如x和y从-50到50的这个矩形坐标区域内，随机取点，如果构成三角形就为一个随机三角形，到时候移到中心处只需要x和y坐标各加长宽的一半就好了，方向也是-180度到180度取随机数，便于到时候用斜率计算移动后的位置 画三角形自定义surfaceView的通用写法都一样，随便看一下文章 Android中的SurfaceView详解:https://www.jianshu.com/p/b037249e6d31 我们先清空画布，然后可以随机生成一些三角形，保存所有生成的三角形到一个集合里面，然后设定一个速度，根据每个三角形的方向来计算距离上一次刷新移动到了哪个位置，通过位置计算与中心点的距离来设置透明度，然后画上去 1234567891011121314151617181920//三角形移动速度private double moveSpeed = 0.4;//刷新时间private static int refreshTime = 20;//添加两次三角形的间隔private static int addTriangleInterval = 100;//每次添加的数量限制private static int addTriangleOnece = 2;//总三角形数量private int allTriangleCount = 100;mCanvas = mSurfaceHolder.lockCanvas();mCanvas.drawColor(0, PorterDuff.Mode.CLEAR);manageTriangle((int) (refreshTime * moveSpeed));for (Triangle triangle : triangleList) { drawTriangle(mCanvas, triangle, mPaintColor);}mSurfaceHolder.unlockCanvasAndPost(mCanvas);Thread.sleep(refreshTime); 具体代码看项目源码，这里注意需要设定几个值来调整动画效果到最佳，做的过程中也有出现一些很魔性的动画，很有意思 然后发现，surfaceView的动画会出现在imageView的上面，虽然我把imageView的高度调了一下还是没效果，发现是之前设置surfaceView透明的时候setZOrderOnTop(true)导致的问题；但是如果不设置surfaceView又会遮挡背景，的确是没好办法解决 其实可以简单点，判断三角形的移动距离小于imageView的时候设置全透明就好了，做出来大概是这样的效果： 视频效果：http://oy5r220jg.bkt.clouddn.com/record__1107012332_1.mp4 其实还是有一点问题的，可以把Imageview的旋转在surfaceView里面实现，这个应该三角形的出现可以会自然一点，其他解决办法倒是暂时没想到 优化为了让三角形出现自然一点，可以把Imageview的旋转在surfaceView里面实现，但是好像不好做，因为还得裁剪图片和控制旋转,相比imageView来实现我觉得稍微有点麻烦了；那还可以不设置setZOrderOnTop(true)，这样背景变成了黑色，还需要画一个背景上去； 那么两种方法比较一下，其实模糊化以后的背景质量非常小（图片都模糊了肯定小呀），远远小于要旋转的那张图片的质量，所以绘制surfaceView背景可能比较好； 获取控件的截图由于我的surfaceView不是宽高全屏的，只是中间一部分，而且给surfaceView设置的背景图片肯定要和整个布局的背景重合，可以先获取背景视图的截图，然后在这里面裁剪出surfaceView所在区域 1234567891011//启用DrawingCache并创建位图iv_bg.setDrawingCacheEnabled(true);iv_bg.buildDrawingCache();//获取bitmapBitmap bitmap2 = Bitmap.createBitmap(iv_bg.getDrawingCache());//裁剪bitmap2 = Bitmap.createBitmap(bitmap2, 0, jinyunView.getTop(), jinyunView.getWidth(), jinyunView.getHeight());//bitmap2传给surfaceViewjinyunView.setBitmapBg(bitmap2);//关闭DrawingCacheiv_bg.setDrawingCacheEnabled(false); 为什么要先获取背景视图的截图，而不直接用那个模糊化的图片呢，因为模糊化的图片尺寸超级小，显示的时候被放大了，而且可能还被裁剪了（背景用的imageView显示的），为保证裁剪后和背景重合还得做很多图象处理，还是直接获取截图来的简单 动态获取颜色关于三角形的颜色，其实也是要根据背景来设定的 Material Design鼓励使用动态颜色，新的Palette支持库可以提取图片中的一部分颜色来设置你的UI的样式来使界面颜色互相搭配以提供一种沉浸式体验。提取出来的调色板（palette）包括突出的和柔和的色调Vibrant （有活力）Vibrant dark（有活力 暗色）Vibrant light（有活力 亮色）Muted （柔和）Muted dark（柔和 暗色）Muted light（柔和 亮色） 就是可以从bitmap中获取几种特殊的颜色，注意获取到的swatche可能为空的 1234567891011121314// Palette的部分Palette palette = Palette.generate(bitmap);Palette.Swatch swatche = null;//获取不同风格的颜色，swatche = palette.getVibrantSwatch();swatche = palette.getLightVibrantSwatch();swatche = palette.getDarkVibrantSwatch();swatche = palette.getMutedSwatch();//我用这个和网易云接近，其他颜色也都挺漂亮swatche = palette.getLightMutedSwatch();swatche = palette.getDarkMutedSwatch();swatche = palette.getVibrantSwatch();//获取颜色int color = swatche.getRgb(); 视频效果：http://lc-fgtnb2h8.cn-n1.lcfile.com/7f08b2eea6a4039cf453.mp4换个颜色：http://lc-fgtnb2h8.cn-n1.lcfile.com/45e70109d2cbc9b7371b.mp4 改变图片的亮度但是发现一个问题，背景颜色太亮了，我选择palette.getLightMutedSwatch()是最亮的颜色，还是会被背景干扰，这个设置最上层的布局背景为半透明，发现我surfaceView也跟着被半透明覆盖了呀，如果只覆盖背景的话，surfaceView绘制的背景是从作为背景的ImageVIew截取的图片，会和背景颜色不一样的，只能从背景ImageView入手，还真的有改变亮度的办法，不仅可以改变亮度，还可以改变色相和饱和度 12345ColorMatrix colorMatrix = new ColorMatrix();//改变图片亮度colorMatrix.setScale(0.5f,0.5f,0.5f,1);ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);iv_bg.setColorFilter(colorFilter); 改变了亮度后对动态获取颜色会有影响，亮色的可能获取不到了，获取颜色应该提前获取 开始画线仔细看了一下，先画围绕这个圆画很多点，隔一段一个点，然后把点用曲线圈起来就ok了，动的时候就是设置一个上下移动的距离，一个点变成两个，两个点先连线，然后同一侧的点重新连成曲线，感觉是是这样的，先试试 围绕圆画点这个就是直线和圆的交点问题，从-180度到180度，每间隔一个角度，取斜率计算交点，差不多是这个意思 12y = (Math.sin(angle) * circleR);x = (Math.cos(angle) * circleR); 画出来一看，这是什么情况，根本不均匀，没道理呀，原来是Math.sin(angle)和Math.cos(angle)里面的值指的是弧度，不是角度，所以转换一下 12y = (Math.sin(Math.toRadians(angle)) * circleR);x = (Math.cos(Math.toRadians(angle)) * circleR); 画贝塞尔曲线我先用二阶贝塞尔曲线把相邻的点连了起来，中间的点取的是两个点的圆弧中间的点，反正看起来是一个圆 12345Path path = new Path();path.moveTo(point.x, point.y);//画二阶贝塞尔曲线path.quadTo(bezierPoint.x, bezierPoint.y, next.x, next.y);canvas.drawPath(path, paint); 原理如下图 处理点的跳动到了最后一步，让点分裂成两个分别上下移动后，再次将同一边的连成曲线并将移动后的上下两个点连线，移动距离先取随机数，效果好了再看音频相关东西，这个有点难度，我尝试了很多次，都不是我想要的结果 看起来都失败了，感觉这个移动距离不能取随机数，最后一个看起来比较像是手动输入了一组均匀的数据，并且是直接画的直线 获取音频信息感觉模拟数据不行，还是先看看怎么获取音频信息；获取音频信息比较简单 1.使用MediaPlayer播放传入的音乐，并拿到mediaPlayerId2.使用Visualizer类拿到拿到MediaPlayer播放中的音频数据（wave/fft）3.将数据用自定义控件展现出来使用Visualizer需要录音的动态权限， 如果播放sd卡音频需要STORAGE权限 12&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 播放音乐12345678MediaPlayer mediaPlayer = MediaPlayer.create(this, R.raw.music_wheresilove);mediaPlayer.setLooping(true);mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { mediaPlayer.start(); }}); Visualizer回调Visualizer.OnDataCaptureListener 有2个回调，一个用于显示FFT数据，展示不同频率的振幅，另一个用于显示声音的波形图 1234567891011private Visualizer.OnDataCaptureListener dataCaptureListener = new Visualizer.OnDataCaptureListener() { @Override public void onWaveFormDataCapture(Visualizer visualizer, final byte[] waveform, int samplingRate) { //到waveform为波形图数据 } @Override public void onFftDataCapture(Visualizer visualizer, final byte[] fft, int samplingRate) { //FFT数据，展示不同频率的振幅 } }; Visualizer 有两个比较重要的参数设置可视化数据的数据大小 范围[Visualizer.getCaptureSizeRange()[0]Visualizer.getCaptureSizeRange()1]设置可视化数据的采集频率 范围[0Visualizer.getMaxCaptureRate()] 123456789visualizer = new Visualizer(mediaPlayer.getAudioSessionId());//采样的最大值int captureSize = Visualizer.getCaptureSizeRange()[1]; //采样的频率int captureRate = Visualizer.getMaxCaptureRate() * 3 / 4;visualizer.setCaptureSize(captureSize);visualizer.setDataCaptureListener(dataCaptureListener, captureRate, true, true);visualizer.setScalingMode(Visualizer.SCALING_MODE_NORMALIZED);visualizer.setEnabled(true); 有一个很有意思的地方，如果audioSessionId设置为零，就直接获取系统的音频，这个很有意思，连蒙带猜搞出来的 1visualizer = new Visualizer(0); 这样纸我们就拿到了两组数据，波形图和频谱图，很显然频谱图是展示不同频率的振幅的，一般情况下只有少部分频率会变动，所以我选择波形图。 拿到的波形图是一个byte数组，里面也是类似每个点的振幅，我们把数组里的数据作为高度画一条线，排成一排正常画出来 12345678910111213141516//画音频线 private void drawAudioLine(Canvas canvas) { if (mPoints == null || mPoints.length &lt; mBytes.length * 4) { mPoints = new float[mBytes.length * 4]; } for (int i = 1; i &lt; pointSize; i++) { if (mBytes[i] &lt; 0) { mBytes[i] = 127; } mPoints[i * 4] = getWidth() * i / pointSize; mPoints[i * 4 + 1] = getHeight() / 2; mPoints[i * 4 + 2] = getWidth() * i / pointSize; mPoints[i * 4 + 3] = 2 + getHeight() / 2 - mBytes[i]; } canvas.drawLines(mPoints, mPaint); } 效果是这样纸，用另一个频谱图也差不多，就是变化的区域有点少 这样纸的话，那是不是我把它绕圆一圈，然后在按相反方向绕一圈，同样跳动的两个点连线，然后随便画画曲线是不是就ok啦；做完就发现里面的值太大了，都看不出来是个圆了，那就都减去一点高度什么的，调整一下大小；然后这次就先画一个三次贝塞尔曲线吧，画出来跟跟屎一样，这个曲线是真的难画呀，而且画的慢，看起来不是很流畅；我再次尝试用简单的方法画 折线的顶点时候用圆角，并没有什么乱用 1mPaint.setStrokeJoin(Paint.Join.ROUND); 设置path中的连接处有个角度，看起来接近了一些，不过还是差很远 12CornerPathEffect cornerPathEffect = new CornerPathEffect(130);mPaint.setPathEffect(cornerPathEffect); 视频效果：http://lc-fgtnb2h8.cn-n1.lcfile.com/fada1f97f943dd6e944d.mp4 其实可以看出来做法是没有问题的，但是必须先对数据进行处理才能得到想要的效果，但是具体怎么处理这个的确需要不断尝试；如果处理好可以做出更多更好看的效果； 其他效果（下载视频才能正常播放）：http://lc-hfysfg0s.cn-n1.lcfile.com/19962ada548649c692ed.mp4 上面的视频效果在github的之前的提交版本里，有兴趣可以找找，现在在不断尝试新的效果，有找到比较好的，会更新上来；有谁搞出炫酷的效果，希望大家不吝赐教 有想法的同学记得告诉我呀，使用前需要先播放音乐哦，声音不能设置太小 视频转Gif工具实现：https://www.jianshu.com/p/81cb36b610f4视频的裁剪其实也是上面这个项目的代码，但是暂时没有做功能，会更新项目地址：https://github.com/tyhjh/Jinyuneffect","link":"/2020/11/16/Android%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%B2%B8%E4%BA%91%E9%9F%B3%E6%95%88%E5%8A%A8%E6%95%88/"},{"title":"实现Android换肤","text":"之前看过一点关于Android换肤的文章，插件化、Hook、无缝换肤什么的，听起来好像很难的样子，也没有好好看；现在关于换肤的开源项目现在也比较多，但其实原理都差不多；最近看了一下，自己实现了一波，感觉还是很简单的样子；这里也只是讲讲换肤的原理，知道了原理每个点就可以快速学习，然后完成整个流程；具体实现可以看代码； 换肤原理换肤其实很简单，说白了就是修改View的属性，一般就是修改字体颜色、背景、图片等；如果是一个超级简单的界面，最简单的实现方式就是点击换肤的时候把每一个View都重新设置一下属性就完事了； View设置属性简单吧，问题就在于在实际项目中不可能手动去获取到每一个控件进行换肤，因为控件太多了；那么问题就变为如何获取到所有的控件进行属性设置；然后换肤，其实就是换一套皮肤，换一套资源文件对吧，如何去更换资源文件也是一个问题 使用theme实现Activity的theme属性肯定都有用过，theme里面可以设置各种属性，更改了theme里面的属性比如颜色，我们的导航栏什么的使用了theme里面的颜色属性的控件颜色都会改变；可以从这个点入手，设置不同的theme，然后更换theme就可以实现；但是有一个问题，设置theme只有在activity的setContentView之前才有效，所以要实现换肤必须得重启Activity才能实现，而且每次新增皮肤必须重新修改源码，重新打包，这种方法感觉不太行； 获取到所有View所以还是那个问题，如何获取到所有的View进行换肤处理；有一个点就是每个Activity都有setContentView方法，其实猜也能猜到，就是把xml布局解析成一个View对象；有点像AOP（面向切面编程）的思想，如果我们能从这个点切入，拿到每一个生成的View对象，我们就可以统一处理了； 那就是去看源码了，其实很简单，我的MainActivity继承至AppCompatActivity，跟着方法深入下去 12345@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... AppCompatActivity里面的方法，我们跟着layoutResID走，直到layoutResID变为View 1234@Overridepublic void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID);} AppCompatDelegate里面的抽象方法 1public abstract void setContentView(@LayoutRes int resId); AppCompatDelegateImpl里面的实现，其实看到LayoutInflater.from(mContext).inflate(resId, contentParent);这句代码就很熟悉了，我们也会经常使用它去加载布局； 123456789@Overridepublic void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();} 还是一样跟着resId走到LayoutInflater里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); } } 走到这个方法是返回生成的View，那生成View肯定是在inflate(parser, root, attachToRoot);方法里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 找到了生成View的地方 12// Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); 继续看createViewFromTag方法，里面使用各种Factory去创建View 1234567891011121314151617181920212223242526272829try { View view; if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { if (-1 == name.indexOf('.')) { view = onCreateView(parent, name, attrs); } else { view = createView(name, null, attrs); } } finally { mConstructorArgs[0] = lastContext; } } return view; 好的，就是这里了，因为所有加载xml布局创建View的流程都会走到这里来，然后Factory只是一个接口，到这里后从逻辑也可以看出来可能会有不同的Factory去创建View，也就是说不能再深入下去了；我们只需要实现我们的Factory然后设置给mFactory2就可以获取到所有的View了，这里是一个Hook点； 那么问题来了，我们怎么去实现用Factory创建View，这里xml里面的东西已经解析完了，看这个方法的参数，有了attrs和控件类名name，我们自己用反射不就轻松的可以生成View吗； 123View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { ... 还有有最简单的方法，其实系统原来已经实现了对吧，我们照着他写不就完事儿了吗；我们在这里打个断点，进入这个方法，他怎么实现我们就跟着写就完事儿了； 发现是在AppCompatDelegateImpl这个类实现的方法，好的直接看retur的地方，进去进入方法 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) { if (mAppCompatViewInflater == null) { TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); String viewInflaterClassName = a.getString(R.styleable.AppCompatTheme_viewInflaterClass); if ((viewInflaterClassName == null) || AppCompatViewInflater.class.getName().equals(viewInflaterClassName)) { // Either default class name or set explicitly to null. In both cases // create the base inflater (no reflection) mAppCompatViewInflater = new AppCompatViewInflater(); } else { try { Class viewInflaterClass = Class.forName(viewInflaterClassName); mAppCompatViewInflater = (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor() .newInstance(); } catch (Throwable t) { Log.i(TAG, &quot;Failed to instantiate custom view inflater &quot; + viewInflaterClassName + &quot;. Falling back to default.&quot;, t); mAppCompatViewInflater = new AppCompatViewInflater(); } } } boolean inheritContext = false; if (IS_PRE_LOLLIPOP) { inheritContext = (attrs instanceof XmlPullParser) // If we have a XmlPullParser, we can detect where we are in the layout ? ((XmlPullParser) attrs).getDepth() &gt; 1 // Otherwise we have to use the old heuristic : shouldInheritContext((ViewParent) parent); } return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); } 好的，终于看见最终的方法了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs, boolean inheritContext, boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) { final Context originalContext = context; // We can emulate Lollipop's android:theme attribute propagating down the view hierarchy // by using the parent's context if (inheritContext &amp;&amp; parent != null) { context = parent.getContext(); } if (readAndroidTheme || readAppTheme) { // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); } if (wrapContext) { context = TintContextWrapper.wrap(context); } View view = null; // We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) { case &quot;TextView&quot;: view = createTextView(context, attrs); verifyNotNull(view, name); break; case &quot;ImageView&quot;: view = createImageView(context, attrs); verifyNotNull(view, name); break; case &quot;Button&quot;: view = createButton(context, attrs); verifyNotNull(view, name); break; case &quot;EditText&quot;: view = createEditText(context, attrs); verifyNotNull(view, name); break; case &quot;Spinner&quot;: view = createSpinner(context, attrs); verifyNotNull(view, name); break; case &quot;ImageButton&quot;: view = createImageButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckBox&quot;: view = createCheckBox(context, attrs); verifyNotNull(view, name); break; case &quot;RadioButton&quot;: view = createRadioButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckedTextView&quot;: view = createCheckedTextView(context, attrs); verifyNotNull(view, name); break; case &quot;AutoCompleteTextView&quot;: view = createAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;MultiAutoCompleteTextView&quot;: view = createMultiAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;RatingBar&quot;: view = createRatingBar(context, attrs); verifyNotNull(view, name); break; case &quot;SeekBar&quot;: view = createSeekBar(context, attrs); verifyNotNull(view, name); break; default: // The fallback that allows extending class to take over view inflation // for other tags. Note that we don't check that the result is not-null. // That allows the custom inflater path to fall back on the default one // later in this method. view = createView(context, name, attrs); } if (view == null &amp;&amp; originalContext != context) { // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); } if (view != null) { // If we have created a view, check its android:onClick checkOnClickListener(view, attrs); } return view; } 仔细看的话，它创建出来的控件都是androidx.appcompat.widget里面的一些比较新的控件，就是升了一下级；其实感觉mFactory2就是Google自己修改皮肤用的； 如果我们的MainActivity继承至Activity的话，同样打断点会进入到另一个创建View的方法；虽然看起来代码很复杂，我们只要记住我们只是来创建View的，其他我们不管，我们自己实现的时候也是这个道理，我们就是实现创建View的方法；所以直接看创建View很简单了，就是直接用反射，传入View的参数AttributeSet，new一个View出来 12345...Object[] args = mConstructorArgs;args[1] = attrs;final View view = constructor.newInstance(args);... 这里还有个问题，既然这里可能有不同的Factory来创建View，我们随便实现一个，去设置给mFactory2，那肯定只会用我们的mFactory2来创建了；那是不是有问题，那我们的MainActivity其实继承Activity还是AppCompatActivity都会走我们自己的方法了；那我们的这个Factory到底是应该照着AppCompatActivity走的方法来写还是Activity走的这个方法来写，或者还有其他的方法来写 其实问题不大，正常开发中我们一般只会选一个Activity来做我们的BaseActivity是吧，我们就按照BaseActivity继承的这种类型来写；而且不同的Activity也可以，因为每个Activity的LayoutInflater是不一样的，我们可以实现不同的Factory分别设置给不同的Activity的LayoutInflater就行了； 好的在这里我们实现自己的Factory去创建View对象，就可以趁机保存所有的对象，然后当我们想换肤的时候就可以把每一个对象的属性修改就可以了；至于这里View怎么保存，怎么销毁，怎么防止内存泄漏这些小问题简单提一下，全局监听一下Activity的生命周期就完事了 1application.registerActivityLifecycleCallbacks(new SkinActivityLifecycleCallbacks()); 更换资源文件如何更换资源文件？插件化换肤感觉是最好的方法，通过一个皮肤包，可以理解为我们更换了一套皮肤后重新打的一个apk包；这样点击换肤的时候，我们拿到每一个View控件，获取到当前View对应属性的资源的ID，然后通过这个ID去皮肤包里面获取出对应的资源对象，然后设置给当前View就完成了换肤； 这里面有一个点，就是我们没法更换我们运行的APP里面的资源文件，我们只是从皮肤包里面读取出相应的资源，比如图片，就是读取出Drawable对象，通过setImageDrawable设置给当前的View； 具体如何去读取其实很简单，就是AssetManager通过反射设置apk文件的路径，就可以拿到Resources对象，Resources就可以通过resId拿到各种资源对象； 123456789AssetManager assetManager = AssetManager.class.newInstance(); Method method = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); method.setAccessible(true); method.invoke(assetManager, path); Resources resources = mApplication.getResources(); Resources skinRes = new Resources(assetManager, resources.getDisplayMetrics(), resources.getConfiguration()); //根据ID获取到资源文件Drawable drawable = skinRes.getDrawable(resId); 其实通过皮肤包来实现非常方便，不管是想内置几种皮肤还是上线后更新皮肤包都可以实现，而且不需要改动之前的代码； 整体流程总结一下，其实就是APP启动的时候，通过application.registerActivityLifecycleCallbacks();，监听Activity的生命周期；每个Activity启动的时候，获取Activity的布局加载器LayoutInflater，给它设置一个Factory，首先会用它去创建View，在创建的时候就会给View设置指定皮肤包里面的资源了；然后保存这个Activity里面的每一个View，当再次换肤的时候获取到每一个View，重新设置指定皮肤的资源；当然Activity销毁的时候肯定是要释放掉View的；大致的流程就是这样 缺点这个东西肯定是有缺点的，我们只是针对布局加载器LayoutInflater进行换肤，也就是说，只要是通过LayoutInflater创建的View我们都可以进行换肤；但是如果有些View是我们new出来的，是换不了的，解决方法也很简单，就是手动添加到换肤的View集合里面去； 第二是只换资源文件里面的属性，这没什么好说的，本来就是根据资源文件换肤； 第三就是和theme相关的控件颜色没法换，这个很简单，因为我们从皮肤包里面是获取不到theme对象的；其实获取到也没有办法，因为重新给Activity设置theme是必须重启Activity的；我自己各种看源码，各种反射搞了半天，发现这个东西的确是搞不定的，这个东西比较复杂，因为它不是一个具体的资源文件； 解决方法是在加载View的时候判断一下View，比如RadioButton或者TabLayout这种可以设置属性进去的就单独改改很简单，但是你要是涉及到那些只能跟随theme属性的控件比如Switch这种，那的确是换不了的，theme换不掉，没办法修改颜色； 1234567891011121314151617 if (view instanceof RadioButton) { if (isDrawable()) { RadioButton radioButton = (RadioButton) view; Drawable drawable = SkinResourcesUtils.getDrawable(attrValueRefId); radioButton.setButtonDrawable(drawable); } } if (view instanceof TabLayout) { TabLayout tl = (TabLayout) view; if (isColor()) { int color = SkinResourcesUtils.getColor(attrValueRefId); tl.setSelectedTabIndicatorColor(color); } } 只能说有相应的替代方案，做不到完美；包括自定义Factory也是一样的，包括自定义View也需要自己适配，换肤这种东西感觉没有一个万能的，完美的方案，只能是针对不同的项目有不同的解决方法； 其实还是不错了，有些问题虽然存在，但是实际项目中换肤应该都比较简单，随便写写，适配一下肯定没问题的； 项目地址：https://github.com/tyhjh/Skinpeeler","link":"/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/"}],"tags":[{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"内存泄露","slug":"内存泄露","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"辅助","slug":"辅助","link":"/tags/%E8%BE%85%E5%8A%A9/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"自动化","slug":"自动化","link":"/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"局域网","slug":"局域网","link":"/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"端口映射","slug":"端口映射","link":"/tags/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"name":"IP地址","slug":"IP地址","link":"/tags/IP%E5%9C%B0%E5%9D%80/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"},{"name":"内存映射","slug":"内存映射","link":"/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"插件化","slug":"插件化","link":"/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"换肤","slug":"换肤","link":"/tags/%E6%8D%A2%E8%82%A4/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"网络技术","slug":"网络技术","link":"/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"}]}