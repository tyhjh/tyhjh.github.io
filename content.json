{"pages":[],"posts":[{"title":"Android WebView与JavaScript的交互","text":"之前有写过WebView的小demo，之后一直没有在项目中使用过网页开发，最近准备重新再看一下，记录一些基本的使用方法 相关链接：[Android使用JsBridge与JavaScript交互](https://www.jianshu.com/p/4ed80af1c103) JavaScript调用Android方法 第一种是用webView的JavascriptInterface注解进行对象映射 第二种是通过webViewClient的shouldOverrideUrlLoading()方法拦截URL 第三种是通过WebChromeClient的onJsAlert()、onJsConfirm()、onJsPrompt()来拦截JS对话框alert()、confirm(); 对象映射比较简单，在Android的对象里面申明一些方法，暴露给JavaScript，传递这个对象给JavaScript，JavaScript就可以调用这些方法 12345678910111213141516171819webView = findViewById(R.id.wbView);//支持JavaScriptwebView.getSettings().setJavaScriptEnabled(true);//加载本地HTML文件webView.loadUrl(&quot;file:///android_asset/test.html&quot;);//传递对象给JavaScriptwebView.addJavascriptInterface(MainActivity.this, &quot;activity&quot;);/** * 暴露给JavaScript的方法 * * @param msg */@JavascriptInterfacepublic void showToast(String msg) { Toast.makeText(MainActivity.this, msg, Toast.LENGTH_SHORT).show();} HTML代码，放在assets文件下的HTML 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;js调用android原生代码&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gb2312&quot;&gt; &lt;meta id=&quot;viewport&quot; name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,minimal-ui&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;br/&gt;&lt;li&gt;&lt;a onclick=&quot;activity.showToast('你好呀');&quot;&gt;点击调用Toast&lt;/a&gt;&lt;/li&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 调用方法返回数据返回数据肯定和刚才那个是一样的，只是方法有返回值而已，只是测试的时候，因为我们不怎么会JavaScript呀，不知道HTML怎么使用这个JavaScript返回来的值，所以有些难搞；我试了两种方法证明的确拿到这个值了，其实怎么用我感觉也不用我们关心，我是找到一个类似Toast的JavaScript方法，用它展示获取到的返回值； 123456789/** * 返回信息给JavaScript * * @return */@JavascriptInterfacepublic String getMsg() { return &quot;Hello from Android&quot;;} 同样还是暴露一个方法给JavaScript，然后第一种方法是在HTML中获取到数据，然后调用HTML中的JavaScript显示 12345678910111213141516171819&lt;!--一个类似Toast的JavaScript方法，不用管怎么搞的--&gt;&lt;script&gt; function toast(msg,duration){ duration=isNaN(duration)?3000:duration; var m = document.createElement('div'); m.innerHTML = msg; m.style.cssText=&quot;width: 60%;min-width: 150px;opacity: 0.7;height: 30px;color: rgb(255, 255, 255);line-height: 30px;text-align: center;border-radius: 5px;position: fixed;top: 40%;left: 20%;z-index: 999999;background: rgb(0, 0, 0);font-size: 12px;&quot;; document.body.appendChild(m); setTimeout(function() { var d = 0.5; m.style.webkitTransition = '-webkit-transform ' + d + 's ease-in, opacity ' + d + 's ease-in'; m.style.opacity = '0'; setTimeout(function() { document.body.removeChild(m) }, d * 1000); }, duration); }&lt;/script&gt;&lt;!--调用Android的getMsg()方法获取返回值，方法前面这个window好像可以加可以不加--&gt;&lt;li&gt;&lt;a onclick=&quot;toast(window.activity.getMsg(),100)&quot;&gt;点击获取MSG&lt;/a&gt;&lt;/li&gt; 第二种就是直接在JavaScript中获取 123456789101112131415161718192021&lt;!--一个类似Toast的JavaScript方法，我小改了一下，调用了Android的getMsg()方法--&gt;&lt;script&gt; function toast(duration){ &lt;!--在这里获取返回值--&gt; var msg=window.activity.getMsg(); duration=isNaN(duration)?3000:duration; var m = document.createElement('div'); m.innerHTML = msg; m.style.cssText=&quot;width: 60%;min-width: 150px;opacity: 0.7;height: 30px;color: rgb(255, 255, 255);line-height: 30px;text-align: center;border-radius: 5px;position: fixed;top: 40%;left: 20%;z-index: 999999;background: rgb(0, 0, 0);font-size: 12px;&quot;; document.body.appendChild(m); setTimeout(function() { var d = 0.5; m.style.webkitTransition = '-webkit-transform ' + d + 's ease-in, opacity ' + d + 's ease-in'; m.style.opacity = '0'; setTimeout(function() { document.body.removeChild(m) }, d * 1000); }, duration); }&lt;/script&gt;&lt;!--直接调用JavaScript方法就完事儿了--&gt;&lt;li&gt;&lt;a onclick=&quot;toast(100)&quot;&gt;点击获取MSG&lt;/a&gt;&lt;/li&gt; 拦截URLJavaScript简单的发送一些消息 1234567&lt;script&gt; function callAndroid(){ &lt;!--约定的url协议为：js://webview?name=Tyhj--&gt; document.location = &quot;js://webview?name=Tyhj&quot;; }&lt;/script&gt;&lt;li&gt;&lt;a onclick=&quot;callAndroid()&quot;&gt;点击测试拦截URL&lt;/a&gt;&lt;/li&gt; Android通过webView.setWebViewClient()重写shouldOverrideUrlLoading方法，拦截到URL，对协议进行解析，获取信息，从而响应JavaScript发送的数据 123456789101112131415public static final String URL_SCHEME = &quot;js&quot;;public static final String URL_AUTHORITY = &quot;webview&quot;;webView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { Uri uri = request.getUrl(); //判断协议，约定的url协议为：js://webview?name=Tyhj if (URL_SCHEME.equals(uri.getScheme()) &amp;&amp; URL_AUTHORITY.equals(uri.getAuthority())) { String name = uri.getQueryParameter(&quot;name&quot;); Toast.makeText(MainActivity.this, &quot;JavaScript通过拦截调用Android代码&quot; + name, Toast.LENGTH_SHORT).show(); return true; } return super.shouldOverrideUrlLoading(view, request); } }); 拦截JS对话框正常网页是会弹出弹窗让我们点击操作或者输入操作返回一些值；现在我们监听到之后返回true而不是默认的方法，这时候就是拦截了这些对话框，网页就不会弹出来，但是也需要我们做响应的处理，并且返回值给JavaScript； JavaScript简单的弹出对话窗 12345678910111213141516171819202122&lt;li&gt;&lt;a onclick=&quot;alert('alert测试')&quot;&gt;点击测alert&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;showPrompt()&quot;&gt;点击测prompt&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onclick=&quot;showConfirm()&quot;&gt;点击测confirm&lt;/a&gt;&lt;/li&gt;&lt;script&gt; function showPrompt() { var person = prompt(&quot;Please enter your name&quot;, &quot;Harry Potter&quot;); if (person != null) { document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello &quot; + person + &quot;! How are you today?&quot;; } }&lt;/script&gt;&lt;script&gt; function showConfirm(){ var r=confirm(&quot;Press a button!&quot;); if(r==true){ document.getElementById(&quot;demo&quot;).innerHTML =&quot;you choose yes&quot;; }else{ document.getElementById(&quot;demo&quot;).innerHTML =&quot;you choose no&quot;; } }&lt;/script&gt; Android对这些方法进行拦截，并做出数据的展示，返回响应的值 12345678910111213141516171819202122webView.setWebChromeClient(new WebChromeClient() { @Override public boolean onJsAlert(WebView view, String url, String message, JsResult result) { Toast.makeText(MainActivity.this, &quot;onJsAlert：&quot; + message, Toast.LENGTH_SHORT).show(); result.confirm(); return true; } @Override public boolean onJsConfirm(WebView view, String url, String message, JsResult result) { Toast.makeText(MainActivity.this, &quot;onJsConfirm：&quot; + message, Toast.LENGTH_SHORT).show(); result.cancel(); return true; } @Override public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) { Toast.makeText(MainActivity.this, &quot;onJsPrompt：&quot; + message, Toast.LENGTH_SHORT).show(); result.confirm(&quot;Tyhj&quot;); return true; } }); Android调用JavaScript方法 第一种是webView的loadUrl()方法，无法获取返回值 第二种是webView的evaluateJavascript()方法，可以获取返回值 调用loadUrl方法调用JavaScript的方法比较简单，直接调用就可以了，遇到一个问题是我在加载网页后直接调用JavaScript的方法发现一直不行，是网页还没有加载完成所以没法调用，监听一下网页加载完成再调用就好了 12345678910webView.loadUrl(&quot;file:///android_asset/test.html&quot;);webView.setWebViewClient(new WebViewClient() { @Override public void onPageFinished(WebView view, String url) { String msg = &quot;呵呵呵&quot;; int duration = 1000; //调用JavaScript的toast()方法 webView.loadUrl(&quot;javascript:toast('&quot; + msg + &quot;','&quot; + duration + &quot;')&quot;); }}); 调用evaluateJavascript方法获取返回值这个方法适用于Android4.4版本以上，以下版本其实也有一些应对的办法，可以自己找找 123456webView.evaluateJavascript(&quot;javascript:getMsg()&quot;, new ValueCallback&lt;String&gt;() { @Override public void onReceiveValue(String value) { Toast.makeText(MainActivity.this,value,Toast.LENGTH_SHORT).show(); } }); 其实可以看出来，基本上只支持传递字符串而已，但是支持字符串，就意味着支持基本类型（自己强转一下）和Json数据了 Android注入js代码有时候网页并不是我们定制的，里面没有我们需要的JavaScript代码，我们可以注入JavaScript代码进去；比如网页上的图片，我们可以提供查看和保存图片的功能，就需要注入JavaScript 12345678910111213141516171819202122232425262728/** * 这段js函数的功能是，遍历所有的img节点，并添加onclick函数， * 函数的功能是在图片点击的时候调用本地java接口imageClick()并传递url过去 */public static final String GET_IMAGE_URL = &quot;javascript:(function(){&quot; + &quot;var objs = document.getElementsByTagName(\\&quot;img\\&quot;);&quot; + &quot;for(var i=0;i&lt;objs.length;i++)&quot; + &quot;{&quot; + &quot;objs[i].onclick=function(){window.activity.imageClick(this.getAttribute(\\&quot;src\\&quot;));}&quot; + &quot;}&quot; + &quot;})()&quot;; webView.loadUrl(&quot;file:///android_asset/test.html&quot;);//传递对象给JavaScriptwebView.addJavascriptInterface(MainActivity.this, &quot;activity&quot;);//在这里注入JavaScriptwebView.loadUrl(GET_IMAGE_URL); /** * 点击图片时候调用 * * @param imgUrl */@JavascriptInterfacepublic void imageClick(String imgUrl) { //获取到图片的URL，可以在此操作图片 Toast.makeText(MainActivity.this, imgUrl, Toast.LENGTH_SHORT).show();} WebView长按事件网页中相应Android的长按事件也是经常用到的，比如刚才的点击一般是查看图片，长按保存图片或者其他操作；其实就是设置WebView的长按事件，然后通过WebView的getHitTestResult()的函数可以获取点击页面元素的类型，然后，我们再根据类型进行相应的处理，还是以图片为例 1234567891011121314webView.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { final WebView.HitTestResult hitTestResult = webView.getHitTestResult(); // 如果是图片类型或者是带有图片链接的类型 if (hitTestResult.getType() == WebView.HitTestResult.IMAGE_TYPE || hitTestResult.getType() == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE) { String picUrl = hitTestResult.getExtra(); Toast.makeText(MainActivity.this, &quot;长按获取到图片地址：&quot; + picUrl, Toast.LENGTH_SHORT).show(); return true; } return false; } }); 监听图片选择这个是我随意加的，因为我们都可以互相调用了，那做什么都应该是没问题的，只是看见webView有一个setWebChromeClient方法里面可以监听到图片选择，可以响应一下；就是监听到图片选择以后，调用系统方法选择图片，返回给JavaScript，也比较简单 12345678910111213141516171819202122232425ValueCallback&lt;Uri[]&gt; mUploadMessageArray;int RESULT_CODE = 0;webView.setWebChromeClient(new WebChromeClient() { @Override public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, FileChooserParams fileChooserParams) { mUploadMessageArray = filePathCallback; //选择图片 Intent chooserIntent = new Intent(Intent.ACTION_GET_CONTENT); chooserIntent.setType(&quot;image/*&quot;); startActivityForResult(chooserIntent, RESULT_CODE); return true; } }); @Overrideprotected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { if (requestCode == RESULT_CODE) { if (mUploadMessageArray != null) { Uri result = (data == null || resultCode != RESULT_OK ? null : data.getData()); //这里返回给JavaScript mUploadMessageArray.onReceiveValue(new Uri[]{result}); mUploadMessageArray = null; } }} 然后HTML里面就是简单的选择图片，好像都没有涉及到JavaScript 123&lt;p&gt; &lt;input type=&quot;file&quot; value=&quot;打开文件&quot; /&gt;&lt;/p&gt; 项目源码：https://github.com/tyhjh/WebViewH.git","link":"/2020/12/02/Android%20WebView%E4%B8%8EJavaScript%E7%9A%84%E4%BA%A4%E4%BA%92/"},{"title":"Android动态壁纸实现","text":"阅读原文：https://www.jianshu.com/p/5a5f95f6cd59 最近搞了一下Android的动态壁纸，像实现“萤火视频桌面”那样，本来以为很难的，但是了解了一下感觉还是很容易的。 Android壁纸 WallpaperService与Engine 壁纸运行在一个Android服务之中，这个服务的名字叫做WallpaperService。当用户选择了一个壁纸之后，此壁纸所对应的WallpaperService便会启动并开始进行壁纸的绘制工作。Engine是WallpaperService中的一个内部类，实现了壁纸窗口的创建以及Surface的维护工作。这一层次的内容主要体现了壁纸的实现原理。 WallpaperManagerService 这个系统服务用于管理壁纸的运行与切换，并通过WallpaperManager类向外界提供操作壁纸的接口。这一层次主要体现了Android对壁纸的管理方式。 WindowManagerService 用于计算壁纸窗口的Z序、可见性以及为壁纸应用窗口动画。这一层次主要体现了Android对壁纸窗口的管理方式。 实现首先静态壁纸是很简单的，大概就是如下几种方法，我也没有试过， 使用WallpaperManager的setResource(int ResourceID)方法 使用WallpaperManager的setBitmap(Bitmap bitmap)方法 使用WallpaperManager的setStream(InputStream data)方法 123456789//需要权限&lt;uses-permission android:name = &quot;android.permission.SET_WALLPAPER&quot;/&gt;WallpaperManager wallpaperManager = WallpaperManager.getInstance(this);try { wallpaperManager.setResource(R.drawable.picture);} catch (IOException e) { e.printStackTrace();} 动态壁纸刚才讲了，动态壁纸就是一个服务，我们先创建一个服务并继承WallpaperService。这个服务里面有个内部类Engine，实现了壁纸窗口的创建以及Surface的维护工作。就是说我们可以获取到一个SurfaceHolder，拿到这个东西就好办了，我们可以在上面画自己想要的东西或者把视频输出到上面去。 视频壁纸的实现 代码还是比较简单的，就是壁纸起来的时候播放一下视频，在壁纸不可见时候暂停，再次恢复的时候继续播放 123456789101112131415161718192021222324252627282930313233343536public class VideoWallpaper extends WallpaperService { private MediaPlayer mp; //这里就是返回我们自定义的Engine @Override public Engine onCreateEngine() { return new VideoEngine(); } //自定义Engine class VideoEngine extends Engine { @Override public void onCreate(SurfaceHolder surfaceHolder) { super.onCreate(surfaceHolder); //对视频进行初始化 } @Override public void onSurfaceCreated(SurfaceHolder holder) { //播放视频 } //当桌面不可见的时候的处理 @Override public void onVisibilityChanged(boolean visible) { if visible() { //继续播放视频 } else { //暂停播放 } } @Override public void onDestroy() { super.onDestroy(); //释放资源 } }} 这里只是展示了部分代码，具体的实现还是要自己在不同的生命周期对视频进行处理，逻辑也是比较简单，和正常的视频播放没什么区别 注册服务 是Service那肯定要注册的 123456789101112&lt;service android:name=&quot;ui.service.VideoWallpaper&quot; android:permission=&quot;android.permission.BIND_WALLPAPER&quot;&gt; &lt;!-- 为动态壁纸配置intent-filter --&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.service.wallpaper.WallpaperService&quot; /&gt; &lt;/intent-filter&gt; &lt;!-- 为动态壁纸配置meta-data --&gt; &lt;meta-data android:name=&quot;android.service.wallpaper&quot; android:resource=&quot;@xml/livewallpapervideo&quot; /&gt; &lt;/service&gt; 然后关于”livewallpapervideo.xml”，就是一个正常的布局文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;wallpaper xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:thumbnail=&quot;@mipmap/ic_video&quot; android:description=&quot;@string/wallpaper_description4&quot; /&gt; 设置壁纸 调用系统的接口将壁纸服务设置为系统的壁纸服务即可 1234567891011121314/** * 设置壁纸 * * @param clazz 壁纸服务的类 * @param context */ public static void changePaper(Class clazz, Context context) { Intent chooseIntent; chooseIntent = new Intent(); chooseIntent.setFlags(FLAG_ACTIVITY_NEW_TASK); chooseIntent.setAction(WallpaperManager.ACTION_CHANGE_LIVE_WALLPAPER); chooseIntent.putExtra(WallpaperManager.EXTRA_LIVE_WALLPAPER_COMPONENT, new ComponentName(context.getPackageName(), clazz.getCanonicalName())); context.startActivity(chooseIntent); } 其他玩法 除了将视频作为壁纸以为还可以将GIF作为壁纸，将摄像头获取到的图象作为壁纸，甚至直接自己在SurfaceHolder自己画东西都可以，道理都是一样的 服务器挂了，可以看看本地壁纸 项目地址：https://github.com/tyhjh/liveWallpaper","link":"/2020/11/18/Android%E5%8A%A8%E6%80%81%E5%A3%81%E7%BA%B8%E5%AE%9E%E7%8E%B0/"},{"title":"Android内存泄漏检测和定位","text":"建议阅读Android常见内存泄漏这篇文章，本文的例子来源于文章中的内存泄漏典型例子 内存泄漏检测工具Profiler其实Android studio自带的 Profiler 是不错的，可以很直观看到CPU、内存、网络的变化，但是有时候简单看看是看不出来内存泄漏的，需要知道具体怎么去分析 Android LeakCanaryAndroid LeakCanary易于集成，自动检测出内存泄漏，十分好用 使用Profiler以Android中的静态变量为例 1234567891011121314private static Activity sActivity;@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sActivity = this; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); } 程序是这样的，第一个Activity跳转到第二个Activity，然后finish()返回第一个Activity，我们反复多做几次；正常来讲第二个Activity会被销毁的，但是因为被静态变量引用了，所以应该是无法被回收的； 使用Profiler来查看内存泄漏首先是点击下面那一栏的Profiler按钮，可能还没有选择程序，点击+添加程序，这一步一般在我们操作程序前做，不然都没记录 会显示CPU、内存、网络和能耗四个东西，点进内存里面去看详情信息，其实只看内存的大致情况不能得出什么结论，感觉好像没什么问题 我们点击那个箭头符号（Dump Java heap），来捕获堆转储，堆转储显示在您捕获堆转储时您的应用中哪些对象正在使用内存，选择按包名排序 然后选择我们的程序，就可以看到哪些对象正在使用内存 看见Main2Activity还在内存中，证明它没有被回收掉，内存是发生了泄漏的，其中Main2Activity$1应该是表示Main2Activity里面的第一个匿名内部类对Main2Activity的引用，如果还有其他的匿名内部类，就是$2、$3这样排下去； Heap Dump 右边四列的意思分别如下，一般情况下，如果Shallow Size和Retained Size都非常小并且相等，都可以认为是已经被回收的对象。 Allocations：Java堆中的实例个数 Native Size：native层分配的内存大小。 Shallow Size：Java堆中分配实际大小 Retained Size：这个类的所有实例保留的内存总大小（并非实际大小） 点击Heap Dump中的Main2Activity对象，发现右侧出现了Instance View，再点击Instance View中的对象，出现Reference和上图一样；Reference显示对这个Main2Activity对象的引用，大部分都是系统层面的引用，可以看到第一个是sActivity这个静态变量的引用，就说明是它引起的内存泄漏； 还发现有很多this$0的引用，这个也往往是导致泄漏的原因，点进去查看发现最终还是sActivity的引用；而出现多个this$0是因为我反复操作了很多遍导致创建了很多个Main2Activity对象未被回收 在内存泄漏检查的过程中，我发现经常出现过理论上对象肯定是被回收了，却仍保留的情况。一般情况下，如果Shallow Size和Retained Size都非常小(比如我测试的一个空的activity，大概是270)并且相等，都可以认为是已经被回收的对象。因为系统已经不认为它会被用到，并且没有给它保留分配的内存。 使用Android LeakCanary这个东西特别简单，直接看官网就行了 就是GitHub地址：https://github.com/square/leakcanary 直接集成： 123456dependencies { debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.6.3' releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.6.3' // Optional, if you use support library fragments: debugImplementation 'com.squareup.leakcanary:leakcanary-support-fragment:1.6.3'} 直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情 12345678910111213public class ExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); if (LeakCanary.isInAnalyzerProcess(this)) { // This process is dedicated to LeakCanary for heap analysis. // You should not init your app in this process. return; } LeakCanary.install(this); // Normal app init code... }} 举个栗子以匿名内部类为例，操作流程和之前的例子一样；正常来讲调用了finish()方法，第二个Activity会被销毁的，但是因为使用了匿名内部类，所以sRunnable会持有Main2Activity的引用，而且sRunnable还是一个静态变量，所以会导致Main2Activity不会被回收掉 1234567891011121314151617181920212223public class Main2Activity extends AppCompatActivity { private static Thread sRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sRunnable = new Thread() { @Override public void run() { } }; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); }} 运行程序，然后过一会儿就会收到提醒，检测到了内存泄漏，打开看看；大概意思就是说sRunnable这个对象，它引用了Main2Activity，导致了内存泄漏；这个工具的确非常的简单友好了 参考文章： 使用 Memory Profiler 查看 Java 堆和内存分配 Android Profiler内存泄漏检查","link":"/2020/11/16/Android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%92%8C%E5%AE%9A%E4%BD%8D/"},{"title":"Android常见内存泄漏分析","text":"内存泄漏内存泄漏就是分配的内存空间没有及时回收导致的。可使用的内存变少，应用变卡，最后内存溢出后应用就会挂掉 内存泄漏的检测建议阅读Android内存泄漏检测和定位这篇文章，使用里面的检测方法可以轻松的验证本文中的内存泄漏例子 原因Android内存泄漏大多是因为Activity没有被回收导致的，Activity没有被回收一般分为两种情况 全局的static变量持有Activity的强引用 在Activity生命周期外的线程，持有Activity的强引用 引用类型推荐阅读Java中四种引用类型，感觉是非常容易理解的 静态变量类中定义了静态Activity变量，把当前的Activity赋值给静态变量，如果Activity生命周期结束的时候静态变量没有清空，就会导致内存泄漏。static变量是贯穿整个应用的生命周期的，所以被泄漏的Activity就会一直存在于应用的进程中，不会被回收，同样的持有Activity（Context）的静态变量，比如View也是一样的道理 123456789101112131415private static Activity sActivity;@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); sActivity = this; findViewById(R.id.btn_back).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); } 内部类非静态内部类 和 匿名类 都会潜在的引用它们所属的外部类，但是静态内部类却不会。 12345678910private static Test sTest; private static Test2 sTest2; class Test { } static class Test2 { } private void test() { sTest = new Test(); sTest2=new Test2(); } 1.如果这个非静态内部类实例内部做了一些耗时的操作，就会导致外围对象不会被回收，从而导致内存泄漏 12345678910111213141516171819protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); test(); }private void test() { new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }).start(); } 这个匿名内部类会引用这个Activity，内部开了线程做耗时操作，就会导致这个Activity不能被回收 2.结合上面的静态变量，如果静态变量持有非静态内部类的引用，而非静态内部类引用了该Activity，那就会导致这个Activity不能被回收 123456789101112private static Test sTest; class Test {} private void test() { sTest = new Test(); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); test(); } Test是非静态内部类，sTest是静态变量，注意这个静态变量是在onCreate中初始化的，会持有该Activity的引用，Activity被销毁的时候sTest不置空那么该Activity就无法被回收； 内部类常见情况上面都说了，非静态内部类会引用所属外部类，这时候如果创建一个内部类，而且持有一个静态变量的引用就容易会引起外部类没法被回收；同样的如果该内部类在子线程做了一些耗时操作，属于在Activity生命周期外的线程，也会导致外部类没法被回收；常见的情况有下面几种 Threads上面第一个例子已经写过了 TimerTask匿名内部类嘛，肯定就持有所在Activity的引用，又做耗时操作，肯定内存泄漏 Handler一个道理，匿名内部类嘛，肯定就持有所在Activity的引用，如果执行postDelayed的时候，Activity被销毁，那么Handler持有的Activity没法被回收，就内存泄漏了，而且里面也有一个匿名内部类Runnable持有Activity 1234567891011new Handler(){ @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }.postDelayed(new Runnable() { @Override public void run() { } },10000); 系统服务这个也很好理解，当你使用系统服务的时候，可以注册监听器，会导致服务持有Context的引用，如果在Activity销毁的时候，没有注销掉监听器，就会导致内存泄漏； 1234//传感器的监听器注册SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);sensorManager.registerListener(this, sensor, SensorManager.SENSOR_DELAY_FASTEST); 注册广播接收器也是需要在onDestroy方法里面注销 资源未释放这个简单，一般就各种流、各种资源没有关闭，集合中对象没清理导致，倒是不容易犯错 静态内部类解决内存泄漏1.静态内部类不会持有外部类的引用，所以使用静态内部类可以解决以上问题，如果静态内部类里面需要引用外部类，可以通过弱引用的方式来引用；2.用static的变量引用匿名内部类的实例或将匿名内部类的实例化操作放到外部类的静态方法中 123456789101112131415161718192021222324252627282930//静态内部类private static class Myhandler extends Handler { private final WeakReference&lt;Activity&gt; mActivity; public Myhandler(Activity activity) { mActivity = new WeakReference&lt;Activity&gt;(activity); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); Activity activity = mActivity.get(); // ... } } private final Myhandler mMyhandler=new Myhandler(this);//这样写不会持有外部类的引用private static final Runnable sRunnable = new Runnable() { @Override public void run() { /* ... */ } };@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMyhandler.postDelayed(sRunnable, 1000 * 60 * 10); } 方法没有问题，但是为什么上面的写法sRunnable没有引用外部类而下面的写法会引用呢，会导致内存泄漏呢；我觉得是因为初始化的位置不同，静态变量和静态类先被初始化了，所以没有外部类的引用；感觉是这样的吧 12345678910private static Runnable sRunnable; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sRunnable = new Runnable() { @Override public void run() { /* ... */ } }; } 参考文章： [译]Android内存泄漏的八种可能（上） 记一次Android内存泄漏的优化经历 Android 内存泄漏分析心得","link":"/2020/11/16/Android%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90/"},{"title":"Android实现模块 api 化","text":"原文链接：https://www.jianshu.com/p/902df67e9728 最近看了微信Android模块化架构重构实践这篇文章，刚好自己又正在搭建新项目的框架，用到组件化开发；感觉文章里面的一些技巧很有用，就跟着实现了一下，写一下自己的看法 模块间的交互首先是解决模块之前的依赖问题，模块间肯定是不能相互依赖的，那如何进行数据交互就是一个问题了；比如用户模块和其他模块，其他模块如何在不依赖用户模块的情况下获取到用户信息； 使用EventBus想要获取用户信息，那User类肯定是要引用的，肯定是要提取出User类放到公共模块里面，然后获取User可以通过EventBus来获取数据 公共模块将EventBus发送的Event定义为接口 123456789public interface UserCallback { /** * 获取用户数据 * * @param user */ void getUser(User user);} 然后在用户模块订阅事件，返回用户信息 1234@Subscribepublic void getUser(UserCallback callback){ callback.getUser(new com.dhht.baselibrary.User());} 在其他模块就可以通过EventBus来发送事件获取到用户信息 123456EventBus.getDefault().post(new UserCallback() { @Override public void getUser(User user) { mUser = user; }}); 但是讲道理EventBus还是少用的好，业务多了会生成很多Event类，感觉是有点难受的，而且代码阅读起来非常难； SPI机制SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。 整体机制图如下： 具体的实现（可以略过）首先也是把User放在公共模块里面，获取用户信息的接口也放在公共模块里面 12345678910package com.dhht.baselibrary;public interface UserService { /** * 获取user * * @return */ User getUser();} 然后在用户模块里面实现接口 12345678package com.dhht.user;public class UserImpl implements UserService { @Override public User getUser() { return new User(&quot;UserImpl&quot;); }} 需要在user/src/main/resources/META-INF.services/目录下面新建文件名为com.dhht.baselibrary.UserService的文件，文件内容就是实现类的路径 1com.dhht.user.UserImpl 这个时候再其他模块使用这个实现类就可以通过SPI机制来获取 123456ServiceLoader&lt;UserService&gt; userServices = ServiceLoader.load(UserService.class);Iterator&lt;UserService&gt; iterator = userServices.iterator();while (iterator.hasNext()) { UserService userService = iterator.next(); ToastUtil.showShort(userService.getUser().getName());} ARouter上面的过程稍微有点复杂，也没必要去实现，这个是一种思想，很多路由框架都是借助了这种思想，而且使用非常方便，比如阿里的ARouter框架；用户类不变，接口需要实现IProvider接口 123public interface UserService extends IProvider { UserInfo getUser();} 然后在用户模块实现接口，并且添加@Route注解 123456789101112@Route(path = &quot;/user/UserService&quot;)public class UserServiceImpl implements UserService { @Override public UserInfo getUser() { return new UserInfo(&quot;Tyhj&quot;); } @Override public void init(Context context) { }} 然后在其他模块通过ARouter注解获取实例 12345678@Autowired//(name = &quot;/user/UserService&quot;)UserService mUserService;@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); ARouter.getInstance().inject(this); ... 方法比较简单，相对于正常的代码只是添加了一个注解而已，ARouter的最新版本如下，每个模块都需要添加注解插件（第二行），库（第一行）只需要在公共模块添加就好了； 123//arouterapi 'com.alibaba:arouter-api:1.4.1'annotationProcessor 'com.alibaba:arouter-compiler:1.2.2' 使用ARouter还需要在每个模块的build.gradle的defaultConfig节点下添加如下代码 12345javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } 提取出api模块如果每次有一个模块要使用另一个模块的接口都把接口和相关文件放到公共模块里面，那么公共模块会越来越大，而且每个模块都依赖了公共模块，都依赖了一大堆可能不需要的东西； 所以我们可以提取出每个模块提供api的文件放到各种单独的模块里面；比如user模块，我们把公共模块里面的User和UserInfoService放到新的user-api模块里面，这样其他模块使用的时候可以单独依赖于这个专门提供接口的模块，以此解决公共模块膨胀的问题 自动生成Library为了写代码方便，我们可以在写代码的时候，每个模块的东西都写在一起，比如User提供的接口我们也正常写在用户模块里面，在编译的时候，再使用gradle来自动生成各个api模块，这样会方便很多 原理是这样的，我们把需要单独生成api模块的.java文件改为另一种文件类型比如把UserInfo.java改为UserInfo.api，在设置/Editor/File Type中找到Java类型，添加*.api，然后就可以和Java文件一样使用了； 在项目的setting.gradle文件里面添加方法includeWithApi(&quot;module名字&quot;)，用这个方法来代替include &quot;:module名字&quot;，这个方法会从这个module里面找到以.api结尾的文件，复制到新的module里面并重命名，当然也会复制gradle文件和AndroidManifest文件，以此生成新的api模块 具体实现setting.gradle文件的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138def includeWithApi(String moduleName) { //先正常加载这个模块 include(moduleName) //找到这个模块的路径 String originDir = project(moduleName).projectDir //这个是新的路径 String targetDir = &quot;${originDir}-api&quot; //原模块的名字 String originName=project(moduleName).name; //新模块的名字 def sdkName = &quot;${originName}-api&quot; //todo 替换成自己的公共模块，或者预先放api.gradle的模块 //这个是公共模块的位置，我预先放了一个 新建的api.gradle 文件进去 String apiGradle = project(&quot;:baselibrary&quot;).projectDir // 每次编译删除之前的文件 deleteDir(targetDir) //复制.api文件到新的路径 copy() { from originDir into targetDir exclude '**/build/' exclude '**/res/' include '**/*.api' } //直接复制公共模块的AndroidManifest文件到新的路径，作为该模块的文件 copy() { from &quot;${apiGradle}/src/main/AndroidManifest.xml&quot; into &quot;${targetDir}/src/main/&quot; } //复制 gradle文件到新的路径，作为该模块的gradle copy() { from &quot;${apiGradle}/api.gradle&quot; into &quot;${targetDir}/&quot; } //删除空文件夹 deleteEmptyDir(new File(targetDir)) //todo 替换成自己的包名，这里是 com/dhht/ //为AndroidManifest新建路径，路径就是在原来的包下面新建一个api包，作为AndroidManifest里面的包名 String packagePath = &quot;${targetDir}/src/main/java/com/dhht/${originName}/api&quot;; //todo 替换成自己的包名，这里是baselibrary模块拷贝的AndroidManifest，替换里面的包名 //修改AndroidManifest文件包路径 fileReader(&quot;${targetDir}/src/main/AndroidManifest.xml&quot;, &quot;commonlibrary&quot;,&quot;${originName}.api&quot;); new File(packagePath).mkdirs() //重命名一下gradle def build = new File(targetDir + &quot;/api.gradle&quot;) if (build.exists()) { build.renameTo(new File(targetDir + &quot;/build.gradle&quot;)) } // 重命名.api文件，生成正常的.java文件 renameApiFiles(targetDir, '.api', '.java') //正常加载新的模块 include &quot;:$sdkName&quot;}private void deleteEmptyDir(File dir) { if (dir.isDirectory()) { File[] fs = dir.listFiles(); if (fs != null &amp;&amp; fs.length &gt; 0) { for (int i = 0; i &lt; fs.length; i++) { File tmpFile = fs[i]; if (tmpFile.isDirectory()) { deleteEmptyDir(tmpFile); } if (tmpFile.isDirectory() &amp;&amp; tmpFile.listFiles().length &lt;= 0) { tmpFile.delete(); } } } if (dir.isDirectory() &amp;&amp; dir.listFiles().length == 0) { dir.delete(); } }}private void deleteDir(String targetDir) { FileTree targetFiles = fileTree(targetDir) targetFiles.exclude &quot;*.iml&quot; targetFiles.each { File file -&gt; file.delete() }}/** * rename api files(java, kotlin...) */private def renameApiFiles(root_dir, String suffix, String replace) { FileTree files = fileTree(root_dir).include(&quot;**/*$suffix&quot;) files.each { File file -&gt; file.renameTo(new File(file.absolutePath.replace(suffix, replace))) }}//替换AndroidManifest里面的字段def fileReader(path, name,sdkName) { def readerString = &quot;&quot;; def hasReplace = false file(path).withReader('UTF-8') { reader -&gt; reader.eachLine { if (it.find(name)) { it = it.replace(name, sdkName) hasReplace = true } readerString &lt;&lt;= it readerString &lt;&lt; '\\n' } if (hasReplace) { file(path).withWriter('UTF-8') { within -&gt; within.append(readerString) } } return readerString }}include ':app', ':baselibrary'includeWithApi &quot;:user&quot;includeWithApi &quot;:other&quot; 其实讲的还是比较清楚了，我首先复制.api文件去生成Java文件，想要生成新的api模块，得有gradle和AndroidManifest文件才行，而这个api模块显然不需要过多的配置，于是我自己先生成一个简单的gradle文件，就是其他模块复制过来的，基础配置而已，然后复制到新的api模块搞定，对于AndroidManifest文件，基础模块肯定是没有什么配置的，复制过来使用完事儿； AndroidManifest路径问题下面这个demo是随便写的，不是按照组件化来写的，只是简单展示一下这个脚本的作用而已，组件化框架搭建点这里，第一个版本写完后能运行没发现问题，但是有位兄弟发现build的时候居然失败了，报错如下： 1AGPBI: {&quot;kind&quot;:&quot;error&quot;,&quot;text&quot;:&quot;Program type already present: com.dhht.commonlibrary.BuildConfig&quot;,&quot;sources&quot;:[{}],&quot;tool&quot;:&quot;D8&quot;} 这个错误很常见，意思就是com.dhht.commonlibrary.BuildConfig这个文件重复了，明显是因为我直接拷贝AndroidManifest文件，里面的包名没有修改导致的 12&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.dhht.commonlibrary&quot; &gt; 发现只要将minSdkVersion设置为21就可以避免这个问题 123defaultConfig { minSdkVersion 21 ... 但是后来打包签名apk的又报错了，那其实我们随便设置不同的包名就可以了，但是包名不能设置不存在的路径，所以在新的模块的原包下新建一个api文件夹，然后在复制过来的AndroidManifest里面修改包名，也不用把minSdkVersion设置为21，当然都是脚本完成 12&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.dhht.user.api&quot;&gt; 我这里创建的是Android Library，其实创建Java Library也是一样的，只是我感觉Android Library更好一点；可能感觉稍微有点复杂，其实只需要编写一个通用的setting.gradle文件然后改改.java文件名而已，这个也是微信重构的一个技巧，我觉得还是挺好的 项目地址：https://github.com/tyhjh/module_api","link":"/2020/11/17/Android%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%9D%97api%E5%8C%96/"},{"title":"Android热修复原理及实现（一）","text":"前言自己之前也做过插件化换肤，涉及到的是插件资源文件的加载；最近看到同事培训的插件化涉及到具体代码的加载；想自己了解一下，就先从最常用的热修复开始看起，由于刚开始接触相关的概念，理解也不是很深，但是总体看下来还是比较简单的，这里记录一下自己的理解； 热修复的应用场景热修复就是在APP上线以后，如果突然发现有缺陷了，如果重新走发布流程可能时间比较长，重新安装APP用户体验也不会太好；热修复就是通过发布一个插件，使APP运行的时候加载插件里面的代码，从而解决缺陷，并且对于用户来说是无感的（用户也可能需要重启一下APP）。 热修复的原理先说结论吧，就是将补丁 dex 文件放到 dexElements 数组靠前位置，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的 理解这个原理，需要了解一下Android的代码加载的机制； Android运行流程简单来讲整体流程是这样的：1、Android程序编译的时候，会将.java文件编译时.class文件2、然后将.class文件打包为.dex文件3、然后Android程序运行的时候，Android的Dalvik/ART虚拟机就加载.dex文件4、加载其中的.class文件到内存中来使用 类加载器负责加载这些.class文件的就是类加载器（ClassLoader），APP启动的时候，会创建一个自己的ClassLoader实例，我们可以通过下面的代码拿到当前的ClassLoader 12ClassLoader classLoader = getClassLoader();Log.i(TAG, &quot;[onCreate] classLoader&quot; + &quot;:&quot; + classLoader.toString()); ClassLoader加载类的方法就是loadClass可以看一下源码，是通过双亲委派模型（Parents Delegation Model），它首先不会自己去尝试加载这个类， 而是把这个请求委派给父类加载器去完成，当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类） 时， 子加载器才会尝试自己去完成加载，最后是调用自己的findClass方法完成的 12345678910111213141516171819202122232425protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. c = findClass(name); } } return c;} ClassLoader是一个抽象类，通过打印可以看出来当前的ClassLoader是一个PathClassLoader；看一下PathClassLoader的构造函数，可以看出，需要传入一个dexPath也就是dex包的路径，和父类加载器； 12345//dexPath 包含 dex 的 jar 文件或 apk 文件的路径集，多个以文件分隔符分隔，默认是“：”public PathClassLoader(String dexPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException(&quot;Stub!&quot;);} PathClassLoader是BaseDexClassLoader的子类，除此之外BaseDexClassLoader还有一个子类是DexClassLoader，optimizedDirectory用来缓存优化的 dex 文件的路径，即从 apk 或 jar 文件中提取出来的 dex 文件； 1234public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) { super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException(&quot;Stub!&quot;);} 这两个的区别，网上的答案是 1、DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk2、PathClassLoader只能加载系统中已经安装过的apk 从这个答案可以知道，我们想要加载更新的插件，肯定是使用 DexClassLoader；但是有点离谱的是其实我用两个都能成功，也许我加载的插件包名这些都和原APP一致导致的吧。 类加载器的运行流程具体的实现都在BaseDexClassLoader里面，看一下里面的实现（源码看不了，网上搜一下），下面是一个构造方法 12345public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) { super(parent); this.originalPath = dexPath; this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory);} 构造方法创建了一个DexPathLis，里面解析了dex文件的路径，并将解析的dex文件都存在this.dexElements里面 12345678910111213141516171819202122232425public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) {… //将解析的dex文件都存在this.dexElements里面 this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory);} //解析dex文件private static Element[] makeDexElements(ArrayList&lt;File&gt; files, File optimizedDirectory) { ArrayList&lt;Element&gt; elements = new ArrayList&lt;Element&gt;(); for (File file : files) { ZipFile zip = null; DexFile dex = null; String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) { dex = loadDexFile(file, optimizedDirectory); } else if (name.endsWith(APK_SUFFIX) || name.endsWith(JAR_SUFFIX) || name.endsWith(ZIP_SUFFIX)) { zip = new ZipFile(file); } …… if ((zip != null) || (dex != null)) { elements.add(new Element(file, zip, dex)); } } return elements.toArray(new Element[elements.size()]);} 然后我们再回头看一下ClassLoader加载类的方法,就是loadClass()，最后调用findClass方法完成的;BaseDexClassLoader 重写了该方法，如下 1234567@Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); // 使用pathList对象查找name类 Class c = pathList.findClass(name, suppressedExceptions); return c; } 最终是调用 pathList的findClass方法，看一下方法如下 123456789101112131415161718public Class findClass(String name, List&lt;Throwable&gt; suppressed) { // 遍历从dexPath查询到的dex和资源Element for (Element element : dexElements) { DexFile dex = element.dexFile; // 如果当前的Element是dex文件元素 if (dex != null) { // 使用DexFile.loadClassBinaryName加载类 Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) { return clazz; } } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null;} 结论所以整个类加载流程就是 1、类加载器BaseDexClassLoader先将dex文件解析放到pathList到dexElements里面2、加载类的时候从dexElements里面去遍历，看哪个dex里面有这个类就去加载，生成class对象 所以我们可以将自己的dex文件加载到dexElements里面，并且放在前面，加载的时候就可以加载我们插件中的类，不会加载后面的,从而替换掉原来的class。 热修复的实现知道了原理，实现就比较简单了，就添加新的dex对象到当前APP的ClassLoader对象（也就是BaseDexClassLoader）的pathList里面的dexElements；要添加就要先创建，我们使用DexClassLoader先加载插件，先生成插件的dexElements，然后再添加就好了。 当然整个过程需要使用反射来实现。除此以外，常用的两种方法是使用apk作为插件和使用dex文件作为插件；下面的两个实现都是对程序中的一个方法进行了修改，然后分别打了 dex包和apk包，程序运行起来执行的方法就是插件里面的方法而不是程序本身的方法； dex插件对于dex文件作为插件，和之前说的流程完全一致，先将修改了的类进行打包成dex包，将dex进行加载，插入到dexElements集合的前面即可；打包流程是先将.java文件编译成.class文件，然后使用SDK工具打包成dex文件人，然后APP下载，加载即可； dex打包工具d8 作为独立工具纳入了 Android 构建工具 28.0.1 及更高版本中：C:\\Users\\hanpei\\AppData\\Local\\Android\\Sdk\\build-tools\\29.0.2\\d8.bat；输入字节码可以是 *.class 文件或容器（例如 JAR、APK 或 ZIP 文件）的任意组合。您还可以添加 DEX 文件作为 d8 的输入，以将这些文件合并到 DEX 输出中 1d8 MyProject/app/build/intermediates/classes/debug/*/*.class 具体的代码实现代码的注释已经很详细了，就不再进行说明了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//在Application中进行替换public class MApplication extends Application { @Override public void onCreate() { super.onCreate(); //dex作为插件进行加载 dexPlugin(); } ... /** * dex作为插件加载 */ private void dexPlugin(){ //插件包文件 File file = new File(&quot;/sdcard/FixTest.dex&quot;); if (!file.exists()) { Log.i(&quot;MApplication&quot;, &quot;插件包不在&quot;); return; } try { //获取到 BaseDexClassLoader 的 pathList字段 // private final DexPathList pathList; Field pathListField = BaseDexClassLoader.class.getDeclaredField(&quot;pathList&quot;); //破坏封装，设置为可以调用 pathListField.setAccessible(true); //拿到当前ClassLoader的pathList对象 Object pathListObj = pathListField.get(getClassLoader()); //获取当前ClassLoader的pathList对象的字节码文件（DexPathList ） Class&lt;?&gt; dexPathListClass = pathListObj.getClass(); //拿到DexPathList 的 dexElements字段 // private final Element[] dexElements； Field dexElementsField = dexPathListClass.getDeclaredField(&quot;dexElements&quot;); //破坏封装，设置为可以调用 dexElementsField.setAccessible(true); //使用插件创建 ClassLoader DexClassLoader pathClassLoader = new DexClassLoader(file.getPath(), getCacheDir().getAbsolutePath(), null, getClassLoader()); //拿到插件的DexClassLoader 的 pathList对象 Object newPathListObj = pathListField.get(pathClassLoader); //拿到插件的pathList对象的 dexElements变量 Object newDexElementsObj = dexElementsField.get(newPathListObj); //拿到当前的pathList对象的 dexElements变量 Object dexElementsObj=dexElementsField.get(pathListObj); int oldLength = Array.getLength(dexElementsObj); int newLength = Array.getLength(newDexElementsObj); //创建一个dexElements对象 Object concatDexElementsObject = Array.newInstance(dexElementsObj.getClass().getComponentType(), oldLength + newLength); //先添加新的dex添加到dexElement for (int i = 0; i &lt; newLength; i++) { Array.set(concatDexElementsObject, i, Array.get(newDexElementsObj, i)); } //再添加之前的dex添加到dexElement for (int i = 0; i &lt; oldLength; i++) { Array.set(concatDexElementsObject, newLength + i, Array.get(dexElementsObj, i)); } //将组建出来的对象设置给 当前ClassLoader的pathList对象 dexElementsField.set(pathListObj, concatDexElementsObject); } catch (Exception e) { e.printStackTrace(); } } apk插件apk作为插件，就是我们重新打了一个新的apk包作为插件，打包很简单方便，缺点就是文件大；使用apk的话就没必要是将dex插入dexElements里面去，直接将之前的dexElements替换就可以了； 具体的实现代码的注释已经很详细了，就不再进行说明了 123456789101112131415161718192021222324252627282930313233343536373839/** * apk作为插件加载 */ private void apkPlugin() { //插件包文件 File file = new File(&quot;/sdcard/FixTest.apk&quot;); if (!file.exists()) { Log.i(&quot;MApplication&quot;, &quot;插件包不在&quot;); return; } try { //获取到 BaseDexClassLoader 的 pathList字段 // private final DexPathList pathList; Field pathListField = BaseDexClassLoader.class.getDeclaredField(&quot;pathList&quot;); //破坏封装，设置为可以调用 pathListField.setAccessible(true); //拿到当前ClassLoader的pathList对象 Object pathListObj = pathListField.get(getClassLoader()); //获取当前ClassLoader的pathList对象的字节码文件（DexPathList ） Class&lt;?&gt; dexPathListClass = pathListObj.getClass(); //拿到DexPathList 的 dexElements字段 // private final Element[] dexElements； Field dexElementsField = dexPathListClass.getDeclaredField(&quot;dexElements&quot;); //破坏封装，设置为可以调用 dexElementsField.setAccessible(true); //使用插件创建 ClassLoader DexClassLoader pathClassLoader = new DexClassLoader(file.getPath(), getCacheDir().getAbsolutePath(), null, getClassLoader()); //拿到插件的DexClassLoader 的 pathList对象 Object newPathListObj = pathListField.get(pathClassLoader); //拿到插件的pathList对象的 dexElements变量 Object newDexElementsObj = dexElementsField.get(newPathListObj); //将插件的 dexElements对象设置给 当前ClassLoader的pathList对象 dexElementsField.set(pathListObj, newDexElementsObj); } catch (Exception e) { e.printStackTrace(); } } 总结思路还是很清晰的，主要是要先了解类加载的原理，整体来讲还是比较简单的；采用类加载方案的主要是以腾讯系为主，包括微信的Tinker、QQ空间的超级补丁、手机QQ的QFix、饿了么的Amigo和Nuwa等等；也有一些其他的方法来实现热修复，有空再进行总结分享。 项目源码：https://github.com/tyhjh/HotFix","link":"/2020/12/09/Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"shadowsocks搭建和加速","text":"本文只是介绍shadowsocks工具相关的技术，仅供学习，大家要遵守中国互联网法 Shadowsocks是一种基于Socks5代理方式的网络数据加密传输包，并采用Apache许可证、GPL、MIT许可证等多种自由软件许可协议开放源代码。shadowsocks分为服务器端和客户端，在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。目前包使用Python、C、C++、C#、Go语言等编程语言开发。 搭建很简单Shadowsocks的运行原理与其他代理工具基本相同，使用特定的中转服务器完成数据传输。 在服务器端部署完成后，用户需要按照指定的密码、加密方式和端口使用客户端软件与其连接。在成功连接到服务器后，客户端会在用户的电脑上构建一个本地Socks5代理。浏览网络时，网络流量会被分到本地socks5代理，客户端将其加密之后发送到服务器，服务器以同样的加密方式将流量回传给客户端，以此实现代理上网。 搭建准备我们搭建现在比较流行的shadowsocks，需要一台VPS(Virtual Private Server 虚拟专用服务器)服务器，就是买个国外的服务器，在上面搭建shadowsocks的服务端，我们在我们的设备（各个系统）安装客户端，两个通信实现。 服务器选择VULTR服务器 5美元/月，有个叫搬瓦工的好像是最便宜的，自己随便找一个买，选择CentOS 7最好，因为有个加速功能对内核有要求。最终的网速速度也取决了服务器，用VULTR是可以达到youtube看4k视频的网速的（也看选择的服务器位置，日本之前很好，现在好像出问题了，洛杉矶也可以，网速不理想的可以销毁服务器，重新换一台试试） 开始安装shadowsocks使用root用户登录，运行下面的命令 123wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.shchmod +x shadowsocks-all.sh./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log 输入序号选择版本，推荐选shadowsocksR，根据提示输入密码，端口号，加密方式等，不清楚就直接选择默认就好了，安装完成如下图： 安装BBR加速安装完成以后，发现其实速度可能并不是很快，可以进行加速，加速方法也有不少，好像都对内核有要求，BBR也是让我成功加速的一种，输入命令： 123wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 安装完，重启一下，应该就ok了 启动脚本ShadowsocksR 版：/etc/init.d/shadowsocks-r start | stop | restart | status shadowsocks使用下载安装各系统下载地址，自己找找：https://github.com/shadowsocks 设置服务器配置信息如下图 选择 服务器 -&gt; 打开服务器设定 -&gt; 点击 + 新增服务器 -&gt; 填写地址，端口号，加密方式，密码，点击确定保存，然后再次点击服务器，选择刚才添加的服务器，点击最上面的启动系统代理，PAC模式选择自动代理模式（节省流量，能直接连接的直接连，每个月流量限制是1000GB）","link":"/2020/12/10/shadowsocks%E6%90%AD%E5%BB%BA%E5%92%8C%E5%8A%A0%E9%80%9F/"},{"title":"使用注解框架CatAnnotation","text":"集成方法支持aspectj和jitpack，在工程的grade添加 1234567891011121314... dependencies { classpath 'com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.4' }...//Add it in your root build.gradle at the end of repositories:allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 在使用的module的grade中添加依赖和注解处理器，以及支持aspectj 123456...apply plugin: 'android-aspectjx'...implementation 'com.github.tyhjh.Annotation:annotationlibrary:v1.1.8'annotationProcessor 'com.github.tyhjh.Annotation:annotator:v1.1.8' 需要支持lambda 表达式，在模块的build.gradle的android节点下面添加支持 1234compileOptions { sourceCompatibility = '1.8' targetCompatibility = '1.8' } 使用方法控件的依赖注入初始化需要使用注解的类中需要初始化 12345protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册，进行控件的初始化 CatAnnotation.injectView(this); @ViewById该注解用于控件的初始化，可以传入控件的ID，当控件的ID和变量名一致是可以不传入 123//变量名和控件ID值一样@ViewByIdTextView tvLogin,tvName; 被注解的变量名可以和控件ID值不一样，但是需要手动设置控件ID值，这种方法只能在app模块使用 123//手动设置id@ViewById(R.id.et_pwd)EditText etPwd; @Click该注解为设置控件的点击事件，同样可以传入控件ID，改方法不需要初始化控件，可以直接使用 123456789@Clickvoid tvLogin() { // TODO call server...}@Clickvoid tvLogin(R.id.tvLogin) { // TODO call server...} 点击防抖动新增防抖动功能，使用了@Click注解的按钮默认在300ms内只能点击一次，可以通过设置全局修改，也可以修改单个点击事件的间隔 12345678910111213141516//全局修改点击间隔，需要尽早设置AvoidShake.setClickIntervalTime(1000);//单个设置点击间隔@Click(interval = 100)void txtView() { ...}//不使用注解的控件设置点击间隔txtView.setOnClickListener(new AvoidShakeClickHelper(500, new AvoidShakeListener() { @Override public void onClick(View v) { //todo } })); @Background该注解为方法切换到子线程运行，可以进行延迟执行，方法不能有返回值，否则不生效，delay值默认为0 1234@Background(delay = 1000)void backgroud() { Log.e(&quot;backgroud&quot;, Thread.currentThread().getName() + &quot;：&quot; + System.currentTimeMillis());} @UiThread该注解为方法切换到主线程运行，可以进行延迟执行，方法不能有返回值，否则不生效，delay值默认为0 1234@UiThread(delay = 1000 * 5)void toast(String msg) { Log.e(&quot;UiThread&quot;, Thread.currentThread().getName() + &quot;：&quot; + System.currentTimeMillis());} @RecyclerMore该注解为RecyclerView滑动到底部监听，可以实现下拉加载更多的功能，使用很方便，变量名就是方法名，也可以手动设置控件ID值；可以设置pageSize的值，如果当前加载的item数量小于pageSize那么就不会触发方法，默认滑动到底部监听就会触发方法 12345@RecyclerMore(pageSize = 5)void ryclView() { mList.addAll(mList2); mAdapter.notifyDataSetChanged();} @CheckBoxChange该注解为CheckBox的OnCheckedChange监听方法，被注解的方法需要有下面两个参数 1234@CheckBoxChange void swTest(boolean isChecked, CompoundButton swTest) { Toast.makeText(this, &quot;isChecked：&quot; + swTest.isChecked(), Toast.LENGTH_SHORT).show(); } @ExecuteTime该注解为获取被注解的方法执行的时间 1234567891011//对方法进行注解@ExecuteTimeprivate void etTest() { Toast.makeText(MainActivity.this, &quot;哈哈哈&quot;, Toast.LENGTH_SHORT).show();}//全局注册时间监听ExecuteManager.getInstance().setPrinter((executeTime, annotion, methodInfo) -&gt; { Log.i(TAG,&quot;方法耗时为： &quot;+executeTime); Log.i(TAG,&quot;方法的详情：&quot;+methodInfo.toString()); }); @CustomAnnotation该注解为自定义注解，用于监听方法执行使用，可以用于数据埋点啥的； 1234567891011121314151617181920 //对方法进行注解@CustomAnnotation private void etTest() { Toast.makeText(MainActivity.this, &quot;哈哈哈&quot;, Toast.LENGTH_SHORT).show(); } //对方法执行进行监听ExecuteManager.getInstance().addExecuteListener(new IExecuteListener() { @Override public void before(CustomAnnotation annotation, MethodInfo methodInfo) { //一个方法准备开始执行 Log.i(TAG,&quot;before MethodInfo is &quot;+methodInfo.toString()); } @Override public void after(CustomAnnotation annotation, MethodInfo methodInfo) { //一个方法执行完成 Log.i(TAG,&quot;after MethodInfo is &quot;+methodInfo.toString()); } }); 相关推荐文章 使用注解实现Android线程切换：https://www.jianshu.com/p/89d7b88eb76c Android编译时注解：https://www.jianshu.com/p/3052fa51ee95 Android中注解的使用：https://www.jianshu.com/p/de13b00042d6 项目地址 查看最新版本：https://github.com/tyhjh/Annotation","link":"/2020/12/05/%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%A1%86%E6%9E%B6CatAnnotation/"},{"title":"双十一领喵币","text":"领喵币领喵币又开始了，使用Android的辅助功能可以实现自动领喵币的功能；具体的效果可以下载下面的apk体验 Apk地址：https://github.com/tyhjh/TmallCoin/raw/master/%E5%8F%AF%E8%BF%90%E8%A1%8Capk/%E9%A2%86%E5%96%B5%E5%B8%81.apk备用地址：http://share.tyhjh.com/share/TmallCoin.apk 功能要做的功能就是自动点击按钮，完成这些只需要等待15秒就可以完成的任务；去年领喵币还比较简单，按钮的位置和功能都是固定的，只需要截图，然后判断固定位置的按钮的颜色是红色还是已完成的灰色，就可以点击按钮去另一个界面等待15秒后再返回，缺点就是只能适配一个分辨率的手机，并且今年按钮的位置不是固定的，我们需要区分哪些是可以通过脚本完成的，哪些是通过简单的脚本无法完成的 思路具体的思路是后台开启服务（AccessibilityService），提供一个悬浮窗按钮，进入到领喵币中心以后，点击按钮开始对屏幕进行截屏；通过图像识别识别出按钮上的文字及位置，通过文字判断当前的任务是否是简单浏览就可以完成的，比如去浏览、去逛逛，去搜索等为简单操作，使用Android辅助功能进行模拟点击该位置，然后等待15秒后即可完成，然后再返回继续进行识别；但是比如去完成这样的按钮一般都是比较复杂的，难以通过脚本完成，需要避开；但是也可能去完成按钮的任务也是一个比较简单的浏览的任务，就需要一些技巧去判断； Android辅助功能建议阅读：https://www.jianshu.com/p/8935bde74c50 具体实现在辅助服务（AccessibilityService）里面，开启线程循环截图进行图像识别，识别出所有的文字及位置；OcrResult类为识别出来的结果，包含文字结果和所在位置；文字识别使用的框架是PaddleOCR，也可以通过jitpack库进行引入这个封装的库，可以看实现的源码：https://github.com/tyhjh/WordsFind 1implementation 'com.github.tyhjh:WordsFind:v1.0.3' 第一次识别会对屏幕右方按钮部分的图像进行裁剪和识别，可以识别出大多数简单的操作由脚本去执行；但是有部分操作按钮显示为去完成，实际也是浏览任务的，在按钮的左侧有文字进行说明一般也是带有浏览、逛逛等文字，就需要在按钮部分识别完成并且未找到可执行的任务时，再次对全图进行查找，如果查找到匹配的文字就进行点击； 123456789101112131415//获取屏幕截屏Bitmap bitmap = ScreenShotUtil.getInstance().getScreenShot();//裁剪出识别区域，只识别按钮Bitmap wordsBitmap = Bitmap.createBitmap(bitmap, startX, startY, (int) ((1 - START_X_SCALE) * width), (int) ((1 - START_Y_SCALE) * height));//获取文字所在的区域List&lt;OcrResult&gt; rectList = WordsFindManager.getInstance().runModel(wordsBitmap);//遍历文字找到按钮进行点击boolean isFindTxt = findBtn(rectList);//还是没有可以点击的文字，识别全图if (!isFindTxt) { //获取文字所在的区域 rectList = WordsFindManager.getInstance().runModel(bitmap); //继续遍历文字进行点击 boolean notFinished = findBtn(rectList); } findBtn方法就是通过识别到的文字判断该任务是否可以执行，如果可以执行就进行点击； 12345678910111213141516171819202122232425private static final List&lt;String&gt; btnTexts = Arrays.asList(new String[]{&quot;去浏览&quot;, &quot;去逛逛&quot;, &quot;去搜索&quot;, &quot;去观看&quot;});private boolean findBtn(List&lt;OcrResult&gt; rectList) { //识别到去浏览的按钮 for (OcrResult result : rectList) { //获取识别的文字 String txt = result.getTxt(); //如果文字为可数组里面的文字，表示可以点击 if (btnTexts.contains(txt)) { //获取喵币 getCatCoin(startX, startY, result); return true; } //任务描述的文字处理，有字代表任务可以点 if (txt.contains(&quot;浏览&quot;) || txt.contains(&quot;逛一逛&quot;)) { //判断该任务是不是已完成的任务 if (notFinished(result)) { //获取喵币 getCatCoin(startX, startY, result); return true; } } } return false; } 获取喵币的代码还是比较简单的，就是点击按钮进入浏览的界面，然后等15秒就返回；因为淘宝页面加载等原因，等待的时间大于15秒才能完成任务 123456//点击去浏览clickOnScreen(rect.left + startX, rect.top + startY, 10, null);//等待页面加载3秒+浏览18秒SystemClock.sleep(22 * 1000);//返回performBackClick(); 还有个问题如果文字不是在按钮上识别出来的，比如任务的描述文字包含浏览，但是其实这个任务其实已经完成了，如果识别不到这种情况就会一直点击该任务，所以会保存识别出的已完成文字位置，通过对比识别出来的描述文字浏览和已完成文字的Y坐标，判断是不是同一个任务，判断该任务是否已经完成 12345678for (Rect rect : rectListFinished) { //计算两个文字的顶部的距离 int value = Math.abs(rect.top - result.getRect().top); //如果大于70像素，判断不是一个任务，该任务未被执行过 if (value &lt; 70) { return false; }} 其中录屏截图框架使用的是：https://github.com/tyhjh/ScreenShot，也可以通过jitpack库进行引入 1implementation 'com.github.tyhjh:ScreenShot:v1.0.2' 思路还是比较清晰的，图像识别找可以浏览完成的任务，定时浏览完成任务；代码也比较的简单，示例代码有所删减，详细的实现可以看源码； 项目地址：https://github.com/tyhjh/TmallCoin","link":"/2020/11/16/%E5%8F%8C%E5%8D%81%E4%B8%80%E9%A2%86%E5%96%B5%E5%B8%81/"},{"title":"用自己电脑搭建公网可访问的服务器","text":"原文链接：https://www.jianshu.com/p/3c43afeb9cb1 IP地址今天突然想到一个存在很久的疑问，服务器和普通电脑有什么不同呢？在我看来最大的区别就是服务器有固定的IP，自己电脑的IP是变化。 就我们寝室来讲，首先你在Windows上面获取的192.168.xx.xx这个是本地IP，是路由器分配的，连到同一个路由器上的电脑可以通过这个来访问（同一个局域网内）其他电脑，前提是访问的电脑提供了服务，同理，在同一个局域网内，把一台电脑作为服务器，其他电脑根据IP来访问是没问题的（有时候电脑开启了防火墙也会访问不到，关了就好了）。 那么外网怎么访问呢？首先PC的外网IP是变化，但是一般不重启路由器什么的，不会经常变化。通过这个网站我们可以看到电脑当前的外网IP。而且，你会发现同一个路由器下面的电脑外网IP都是一样的。 通过IP访问自己电脑那通过这个外网IP能不能访问到自己电脑呢，其实没有这样简单。首先，这个外网IP可以算作是路由器的IP，所以意思就是只能访问到路由器，想要访问到路由器下的电脑上，那么要进行端口映射。端口映射很简单，路由器基本自带的功能，路由器设置一下，比如你的电脑本地IP是192.168.31.198（可以在路由器设置固定地址），你的程序端口是8080，那么添加一条端口映射规则，外部、内部端口设置8080，内部IP设置192.168.31.198，就可以了。或者开启DMZ，开启DMZ功能可以将内网某一个设备的IP映射到外网，方便从外网访问到该设备，就是相当于把这个设备当做路由器一样，外网可以直接访问。 使用域名访问那理论上这样做外网是可以访问自己的电脑了，但是作为服务器，你的IP始终在变化，那没法用。比如APP，可以想一些办法，比如IP变了，我们下发通知APP相应改变，但是服务器IP都变了，APP根本没法连接服务器，就无法更改内容；可以把IP存在其他服务器上，自己电脑IP变了，就发送到其他服务器，APP每次都从其他服务器先获取IP，这样有点麻烦了，还需要其他服务器。 其实有很多软件可以做到这件事包括我听的有点多的花生壳，但是收费，不收费就限制你的流量什么的，算了我还是不用了。但是它的解决方案比较有意思，它是卖一个域名给你，通过动态解析域名来实现。具体就是，域名需要解析到一个公网IP才能使用，使用方法和IP地址没什么两样就是好记。当IP改变的时候我重新解析域名到新的IP地址，那不管外网IP怎么变我的域名永远是指向我的电脑的外网IP的，可以通过域名来访问我们的电脑 域名动态解析动态解析叫DDNS，域名不贵，我在阿里云买了两个，一年50块，我网上查了一下，阿里是有API调用来解析域名的，看看文档，申请APPKey什么的。然后下载它的SDK，运行，非常棒，写个程序，隔几分钟获取一次电脑的外网IP，然后获取阿里的解析记录的IP，一样则证明IP没有变，不处理，不一样说明IP变了，重新设置解析，DDNS完事。SDK好像没文档，看看示例代码能猜出用法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static IAcsClient client = null; String regionId = &quot;cn-hangzhou&quot;; //必填固定值，必须为“cn-hanghou” String accessKeyId = &quot;xxxxxxx&quot;; // your accessKey String accessKeySecret = &quot;xxxxxxx&quot;;// your accessSecret public void updateDns() { IClientProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret); client = new DefaultAcsClient(profile); DescribeSubDomainRecordsRequest recordsRequest = new DescribeSubDomainRecordsRequest(); recordsRequest.setSubDomain(&quot;one.yorhp.com&quot;);//设置域名 DescribeSubDomainRecordsResponse recordsResponse; //request.setProtocol(ProtocolType.HTTPS); //指定访问协议 //request.setAcceptFormat(FormatType.JSON); //指定api返回格式 //request.setMethod(MethodType.POST); //指定请求方法 //request.setRegionId(&quot;cn-hangzhou&quot;);//指定要访问的Region,仅对当前请求生效，不改变client的默认设置。 try { recordsResponse = client.getAcsResponse(recordsRequest); List&lt;DescribeSubDomainRecordsResponse.Record&gt; recordList = recordsResponse.getDomainRecords(); for (DescribeSubDomainRecordsResponse.Record record : recordList) { String oldIp = record.getValue(); String outter_ip = IpAddress.getV4IP(); if (!oldIp.equals(outter_ip)) { UpdateDomainRecordRequest udr_req = new UpdateDomainRecordRequest(); udr_req.setRecordId(record.getRecordId()); udr_req.setRR(record.getRR()); udr_req.setValue(outter_ip); udr_req.setType(record.getType()); udr_req.setTTL(record.getTTL()); udr_req.setPriority(record.getPriority()); udr_req.setLine(record.getLine()); UpdateDomainRecordResponse udr_resp = new UpdateDomainRecordResponse(); udr_resp = client.getAcsResponse(udr_req); System.out.println(&quot;重新解析域名成功：&quot;+outter_ip); } else { System.out.println(&quot;域名未改变：&quot;+outter_ip); } } } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } 其中还有个解析生效时间的问题，阿里上一般是10分钟，也就是说你的电脑作为服务器可能会崩溃10分钟，那不好。可以升级一下解析，好像是买一次就好了，我将近600天，50块，每次解析1秒生效。这样纸搞，理论上讲，你就具备把一台电脑作为服务器的技术了，我感觉还是很有用的。 Java获取IP地址通过下面的代码可以获取外网IP，应该就是通过访问另一个服务器上的接口来获取自己的IP地址，然后再返给我们，有个问题是&quot;http://ip.chinaz.com&quot;这个接口是别人的，随时可能会被关掉，所以需要在网上找找其他方法，原理应该都是一样的，只是返回数据不同，解析方式不同而已 123456789101112131415161718192021222324252627282930313233343536373839404142//获取外网IPpublic static String getV4IP() { String ip = &quot;&quot;; String chinaz = &quot;http://ip.chinaz.com&quot;; StringBuilder inputLine = new StringBuilder(); String read = &quot;&quot;; URL url = null; HttpURLConnection urlConnection = null; BufferedReader in = null; try { url = new URL(chinaz); urlConnection = (HttpURLConnection) url.openConnection(); in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), &quot;UTF-8&quot;)); while ((read = in.readLine()) != null) { inputLine.append(read + &quot;\\r\\n&quot;); } //System.out.println(inputLine.toString()); } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } finally { if (in != null) { try { in.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } Pattern p = Pattern.compile(&quot;\\\\&lt;dd class\\\\=\\&quot;fz24\\&quot;&gt;(.*?)\\\\&lt;\\\\/dd&gt;&quot;); Matcher m = p.matcher(inputLine.toString()); if (m.find()) { String ipstr = m.group(1); ip = ipstr; } return ip; } 运营商分配IP但是，事情没有这样简单，这么流行收费软件是有原因的。我做完上面的步骤还是不行，外网还是没办法访问服务器，我检查了很久，发现路由器显示的IP和我获取到的外网IP不一样，理论上都应该是外网IP，应该一样的。用代码获取到的IP肯定是外网IP，那路由器上显示的IP就不是外网IP，我百度了一下： 1234567如果你在路由器中查看到的WAN口IP地址，和外网的IP地址不一样。这种情况是宽带运营商，给你分配的一个内网IP地址；即你路由器WAN口IP地址是一个内网IP地址，很多个宽带用户，共同使用一个外网IP地址上网。之所以出现宽带运营商，给大家分配内网IP地址，让多个宽带账号共享一个外网IP地址上网，应该是IPv4地址不够用的原因。所以，宽带运营商才会才去这种措施，让多个用户共享一个外网IP地址。这情况实际上和我们自己使用路由器上网一样的，我们电脑、手机上获取的是路由器分配的一个内网IP地址，最总多台电脑、手机共同使用路由器中的WAN口IP地址上网。一般来说，WAN口IP和外网IP地址不一样，并不会影响到我们的正常上网；不过在一些特殊网络环境下，会影响到用户的正常使用。例如在路由器中设置端口映射的时候，由于路由器的WAN口和外网IP地址不一样，会导致端口映射失败。 看到没有，有这种情况，就是你的路由器本来就不是用的外网IP，相当于在你的路由器上面还有一个路由器，而且我们没法在那里设置端口映射。有人说可以打电话叫服务商给你换一个外网IP，我感觉我学校是没什么可能，我也没试过，我感觉家里或者公司应该可以。 就是说如果你去刚才那个网站看了你的公网IP如果和你的路由器主界面设置账号那里显示的IP一样的，那好恭喜你，上面那样搞没问题，很简单，也非常好，你想想，阿里一个1G，1核，带宽1M的服务器都是59一个月，你自己电脑带宽100M，性能也好，多好，还免费。所以我有兴趣来搞这个东西。 其他方法那搞了一天白搞了？那不可能，可以看出来之前那个办法已经没有办法实现了，真的是没有办法直接访问自己的电脑了，那还有另一种说法，端口映射内网穿透。这篇文章写的很详细了，端口映射内网穿透方案探索。 其实呢，我看了一下，方法基本上就是通过一些服务来转发请求吧，大概就是你的电脑一直连接另一个服务器，当另一个服务器有一些特定的请求的时候转发给你的电脑，基本道理我觉得是这样吧。那其实和之前那个方法真的是天壤之别了。速度肯定取决于这两台服务器中最慢的一台了，反正感觉没什么优势。 我现在实现了最简单的使用ssh端口转发来做内网穿透。因为非常简单，我试了一下。按照这篇文章使用ssh端口转发来做内网穿透 ,要下载一个xshell软件，免费的。这样的确可以映射成功，但是真的垃圾，玩玩做个网站什么的可以，作为什么文件服务器那不用想了，我写了个下载文件的接口，xshell直接崩了。 1centos7重启ssh服务的命令为 service sshd restart IPV6那其实可以看到，我们的电脑没有固定的IP，服务商甚至都不给我们外网IP，其实我们去找服务商买一个固定的IP，那这个连接的电脑就可以当做服务器使用了。 现在的大部分技术是IPV4，所以静态IP稀缺，导致需要付费使用静态IP，在以后IPV6的使用，几乎可以让地球上每一个人都有一个属于自己的静态IP。 在杭州办了电信宽带，发现有外网IP，直接映射一下的确成功了；祝大家也能成功 总结重点就在于你的宽带账户有没有被分配公网IP，有的话，公网IP就相当于被设置在了你家接入网线的第一个路由器或者猫上面；谁都可以访问这个公网IP，设置一下端口映射就可以把相应端口的访问请求转发到这个路由器下的电脑上，电脑自己来做处理，自己电脑就相当于一台服务器了。有些路由器是Linux系统的，安装一些硬盘什么的可以直接就作为服务器了，都不需要再映射","link":"/2020/11/16/%E7%94%A8%E8%87%AA%E5%B7%B1%E7%94%B5%E8%84%91%E6%90%AD%E5%BB%BA%E5%A4%96%E7%BD%91%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"终端走shadowsocks代理","text":"本文只是介绍代理工具相关的技术，仅供学习，大家要遵守中国互联网法 首先打开shadowsock 打开shadowsocks 自动代理模式 服务器（洛杉矶） 1vim ~/.zshrc 添加代理 123# proxy listalias proxy='export all_proxy=socks5://127.0.0.1:1080'alias unproxy='unset all_proxy' 保存退出 1source ~/.zshrc 使用proxy前先查看下当前的ip地址： 1curl ip.cn IP : 183.156.xxx.xx地址 : 中国 浙江 杭州运营商 : 电信… 或者 1curl cip.cc 执行代理: 1proxy 查看IP，如果ip.cn不能用，可以换个类似的站点查询 1cip.cc IP : 66.42.xx.xx地址 : 美国 美国加利福尼亚州圣华金县斯托克顿市PacWest通信公司… 搞定了，如果不需要走代理，执行： 1unproxy 参考：https://github.com/mrdulin/blog/issues/18","link":"/2020/12/10/%E7%BB%88%E7%AB%AF%E8%B5%B0shadowsocks%E4%BB%A3%E7%90%86/"},{"title":"黑苹果macOS、Windows双系统安装","text":"其实很简单一直用的MacBook Pro 15版，觉得性能有点跟不上了，编译代码什么的比较慢，买新版是不可能的，穷；所以一直想装一台黑苹果，但是觉得好像太麻烦了，怕自己搞不定，我的台式电脑显卡坏了，维修中，玩不了游戏，所以决定搞一下黑苹果，然后发现其实很简单 目标装黑苹果，目的就是为了写代码，完全替换旧的Mac，使用体验必须高于我的Mac；那游戏还是要玩的呀，双系统势在必行； 硬件准备硬件肯定是非常重要的，有些硬件苹果就是不支持；首先肯定得是主机，笔记本没必要，我觉得重点就在于CPU、主板和显卡；其他应该没有什么问题的硬件配置参考这里，如果硬件对不上也没关系 主板只要主流一点，z370、b250这种 显卡gtx10系列的，AMD的好像免驱也很好， CPU 英特尔最近几年的，就应该没问题了； 想要玩游戏和工作，首先要互不干扰，两块固态硬盘是必须的 体验高于MacBook Pro，那么显示器肯定不能是1080P的，4k带鱼屏很爽，DP接口也比较重要； 妙控板肯定是必须的，鼠标肯定是要丢掉的； 键盘改一下键，换换键帽，搞定 我的电脑配置CPU：i7 9700k主板：ROG STRIX Z370-H GAMING显卡：七彩虹 gtx1060 6G显示器：LG 34UC98固态硬盘：Windows一块、MacOS一块 完成度和性能 除了显示器自带的音响DP输出音频不响以外，其他全部正常； 不能升级或更新系统； 两块硬盘，Windows和Mac互不干扰，随便搞，Mac挂了还可以打开Windows挂载另一个硬盘抢救； 启动时候需要手动选择启动项来切换系统； 性能远高于我的macbook Pro 2015； 系统安装好的教程超级重要，这个这个教程非常不错，资源下载超级方便；视频/图文教程都有； 还是有些小问题将 U 盘下的 Clover 文件放入到磁盘下面这一步，其实还要把另一个文件夹BOOT一起放进去的，这样开机选择启动项就有了，不用进入下一步在windows里面添加启动项；因为下一步添加启动项在普通的Windows环境下完不成，只有UEFI的环境可以，不过也可以试一下； 查看教程 完全按照安装教程步骤进行 点击下载 系统镜像：macOS High Sierra 10.13.6(17G65) 点击下载 Clover 驱动配置文件：如果硬件对不上也没问题，我试了i7-7700+华硕B250+10.13和i7-8700K+华硕Z370-i+GTX1060+10.13.4，差距这么大也完全OK，我的硬件都对不上 点击下载 NVIDIA显卡驱动，对号入座 点击下载 Clover Configurator Mac版 点击下载 TransMac 注意我用i7-8700K+华硕Z370-i+GTX1060+10.13.4这个来安装的时候，报一个错，说是安装器资源已过期，简单，安装前先把i7-7700+华硕B250+10.13这个资源里面的CLOVER/kexts/10.13/FakeSMC.kext复制到i7-8700K+华硕Z370-i+GTX1060+10.13.4里面的相应文件夹里面，删除原来的文件；就是说，i7-7700+华硕B250+10.13这个里面的肯定是没有过期的，可以用的，有这个问题就找它复制就好了；要是安装了才发现问题，得删了系统，重新安装 音频驱动一般没问题，DP/HDMI接口输出音频的可能会有问题，安装万能声卡驱动后，HDMI的解决了，DP的没解决；MultiBeast这个软件可以生成万能驱动或者相应的驱动，还行；但是上面有一个专门支持华硕 ROG STRIX系列的主板的驱动，不要选，没什么用，而且开机会变得巨慢，我受不了已经重装了 蓝牙蓝牙随便买一个免驱的，我之前买的绿联的还不错 显示器支持HiDPI显示器型号：LG 34UC98 4k 21:9 带鱼屏这个东西好像就是类似Windows调整缩放比例的意思，放大120%、150%，感觉也没什么卵用；输入分辨率的时候随便输入都行，我是按照放大比例随便输入的；好像发现同一个分辨率，HiDPI结尾的会清晰一些吧 1curl -o ~/enable-HiDPI.sh https://raw.githubusercontent.com/syscl/Enable-HiDPI-OSX/master/enable-HiDPI.sh 回车 1chmod +x ~/enable-HiDPI.sh 回车 1~/enable-HiDPI.sh 回车，然后会提示你输入分辨率，随便输入喽 15880x2880 //高于希望渲染的实际分辨率的合适值 输入0回车，输入电脑密码重启即可 然后就会出来一些新的分辨率，以HIDPi结尾 总结很简单其实看了教程后觉得好简单呀，我反复装了好几次了，都没有问题，搞的时候注意备份clover文件，不行就恢复； 使用习惯然后我觉得最重要的在于使用习惯，你要是之前就习惯mac的使用，习惯使用触控板，你自然会配妙控板，会升级显示器，会觉得很爽；要是还使用鼠标，使用1080P，也没用惯，也不能打游戏，确觉得没什么卵用，那的确没什么卵用；所以要是笔记本装黑苹果，我完全没兴趣，没有Retina屏，没有触控板手势，拿来干嘛呢，还会一大堆驱动问题 性价比性能高配置性能肯定比白苹果好呀，现在MacBook Pro顶配CPU是i9 8950HK，性能都不如i7 8700k；显卡是Radeon Pro 560X，RX 560在天梯上略高于gtx 1050，但是笔记本上的Radeon Pro 560X，RP560=RX560*75% ,所以性能可能还不如台式的gtx 1050； 价格512GB，15-inch MacBook Pro官网价格 2.8万，黑苹果自己配的话，就看自己了，可能不到1/3的价格性就能赶上苹果的性能，而且还是一台完美的Windows 其实有非常简单的办法安装完美的黑苹果，就是买一个AMD的显卡，一般买一个Vage系列，或者RADEON VII基本上就可以不用再折腾了，而且可以随意升级版本，几乎和白苹果没有任何区别；我自己也买了一个AMD的RADEON VII显卡，然后在这个网站https://mirrors.dtops.cc/iso/MacOS/daliansky_macos/下载了一个10.15.2的系统，制作系统，重启安装一步到位，没安装任何驱动，然后升级了若干个版本，没有一点问题；性能跑分碾压所有MacBook Pro，和19年最顶配的IMac持平；","link":"/2020/11/16/%E9%BB%91%E8%8B%B9%E6%9E%9CmacOS%E3%80%81Windows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"title":"Android仿网易云鲸云音效动效","text":"最近网易云音乐出了一个叫鲸云音效东西，效果还不错，播放界面还带了动效，这个就比较炫酷了，感觉比较有意思，所以也想自己做一个，其中一个我觉得比较好看的效果如下（动图的来源也比较有意思，后面会讲）… 具体思路首先自定义布局是了解的，可能会用到surfaceView去绘制，整个动画可以分为四个部分，第一个是旋转的图片，这个好说；第二个是运动并且透明度渐变的三角形，这个画画也简单；第三个是根据音乐变化而变化的一个曲线吧，这个可能比较难，我也没接触过，不过可以试试看，第四个是模糊的背景，这个简单。 具体实现实现模糊的背景这个倒是简单，之前也用过一个模糊背景的工具还不错，不过存在一个问题，我是打算自定义一个surfaceView，给surfaceView画一个背景倒是不难，也遇到两个问题 1.怎么将图片以类似自动裁剪居中的方式画上去，这个想想其实简单，取得画布的大小和bitmap的大小，满足一边进行缩放，裁剪掉多余部分就好了 12345678910111213141516171819202122/** * 裁剪图片 * * @param rectBitmap * @param rectSurface */ public static void centerCrop(Rect rectBitmap, Rect rectSurface) { int verticalTimes = rectBitmap.height() / rectSurface.height(); int horizontalTimes = rectBitmap.width() / rectSurface.width(); if (verticalTimes &gt; horizontalTimes) { rectBitmap.left = 0; rectBitmap.right = rectBitmap.right; rectBitmap.top = (rectBitmap.height() - (rectSurface.height() * rectBitmap.width() / rectSurface.width())) / 2; rectBitmap.bottom = rectBitmap.bottom - rectBitmap.top; } else { rectBitmap.top = 0; rectBitmap.bottom = rectBitmap.bottom; rectBitmap.left = (rectBitmap.width() - (rectSurface.width() * rectBitmap.height() / rectSurface.height())) / 2; rectBitmap.right = rectBitmap.right - rectBitmap.left; } } 2.由于我后面画三角形必须得不停地刷新，背景需要重复绘制，感觉有点浪费资源，看了一下局部刷新什么的感觉没什么用，所以就直接先设置为父布局的普通的背景好了，再将surfaceView设置为透明 123456@Overridepublic void surfaceCreated(SurfaceHolder surfaceHolder) { setZOrderOnTop(true); getHolder().setFormat(PixelFormat.TRANSLUCENT);} Android图片模糊的工具类:https://www.jianshu.com/p/c676fc51f3ef 实现旋转的图片这个更简单，为了方便也是直接使用一个ImageView，通过自带的视图裁剪工具剪裁为圆形，然后通过属性动画来旋转 设置一直旋转的属性动画 123456objectAnimator = ObjectAnimator.ofFloat(ivShowPic, &quot;rotation&quot;, 0f, 360f);objectAnimator.setDuration(20 * 1000);objectAnimator.setRepeatMode(ValueAnimator.RESTART);objectAnimator.setInterpolator(new LinearInterpolator());objectAnimator.setRepeatCount(-1);objectAnimator.start(); 视图裁剪 1234567891011121314151617/** * 设置裁剪为圆形 * * @param view * @param pading 这个是设置间距是长或宽的几分之一 */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public static void setCircleShape(View view, final int pading) { view.setClipToOutline(true); view.setOutlineProvider(new ViewOutlineProvider() { @Override public void getOutline(View view, Outline outline) { int margin = Math.min(view.getWidth(), view.getHeight()) / pading; outline.setOval(margin, margin, view.getWidth() - margin, view.getHeight() - margin); } }); } 实现运动的三角形为了保证性能，这个就得使用surfaceView来做了；大体思路就是随机生成一些三角形，三角形速度大小一样，方向随机，从圆中心向外移动，移动过程将透明度减小到零 三角形有速度不过速度大小都一样就先不用管，有速度方向用角度来代替，也好计算运动后的位置，有三个顶点坐标。 所以三角形的初步定义 12345678910111213public class Triangle { public Point topPoint1, topPoint2, topPoint3; public int moveAngle; public Triangle(Point topPoint1, Point topPoint2, Point topPoint3) { this.topPoint1 = topPoint1; this.topPoint2 = topPoint2; this.topPoint3 = topPoint3; moveAngle = getMoveAngel(); }} 随机生成了三角形简单的方法，就是先指定一个坐标区域比如x和y从-50到50的这个矩形坐标区域内，随机取点，如果构成三角形就为一个随机三角形，到时候移到中心处只需要x和y坐标各加长宽的一半就好了，方向也是-180度到180度取随机数，便于到时候用斜率计算移动后的位置 画三角形自定义surfaceView的通用写法都一样，随便看一下文章 Android中的SurfaceView详解:https://www.jianshu.com/p/b037249e6d31 我们先清空画布，然后可以随机生成一些三角形，保存所有生成的三角形到一个集合里面，然后设定一个速度，根据每个三角形的方向来计算距离上一次刷新移动到了哪个位置，通过位置计算与中心点的距离来设置透明度，然后画上去 1234567891011121314151617181920//三角形移动速度private double moveSpeed = 0.4;//刷新时间private static int refreshTime = 20;//添加两次三角形的间隔private static int addTriangleInterval = 100;//每次添加的数量限制private static int addTriangleOnece = 2;//总三角形数量private int allTriangleCount = 100;mCanvas = mSurfaceHolder.lockCanvas();mCanvas.drawColor(0, PorterDuff.Mode.CLEAR);manageTriangle((int) (refreshTime * moveSpeed));for (Triangle triangle : triangleList) { drawTriangle(mCanvas, triangle, mPaintColor);}mSurfaceHolder.unlockCanvasAndPost(mCanvas);Thread.sleep(refreshTime); 具体代码看项目源码，这里注意需要设定几个值来调整动画效果到最佳，做的过程中也有出现一些很魔性的动画，很有意思 然后发现，surfaceView的动画会出现在imageView的上面，虽然我把imageView的高度调了一下还是没效果，发现是之前设置surfaceView透明的时候setZOrderOnTop(true)导致的问题；但是如果不设置surfaceView又会遮挡背景，的确是没好办法解决 其实可以简单点，判断三角形的移动距离小于imageView的时候设置全透明就好了，做出来大概是这样的效果： 视频效果：http://oy5r220jg.bkt.clouddn.com/record__1107012332_1.mp4 其实还是有一点问题的，可以把Imageview的旋转在surfaceView里面实现，这个应该三角形的出现可以会自然一点，其他解决办法倒是暂时没想到 优化为了让三角形出现自然一点，可以把Imageview的旋转在surfaceView里面实现，但是好像不好做，因为还得裁剪图片和控制旋转,相比imageView来实现我觉得稍微有点麻烦了；那还可以不设置setZOrderOnTop(true)，这样背景变成了黑色，还需要画一个背景上去； 那么两种方法比较一下，其实模糊化以后的背景质量非常小（图片都模糊了肯定小呀），远远小于要旋转的那张图片的质量，所以绘制surfaceView背景可能比较好； 获取控件的截图由于我的surfaceView不是宽高全屏的，只是中间一部分，而且给surfaceView设置的背景图片肯定要和整个布局的背景重合，可以先获取背景视图的截图，然后在这里面裁剪出surfaceView所在区域 1234567891011//启用DrawingCache并创建位图iv_bg.setDrawingCacheEnabled(true);iv_bg.buildDrawingCache();//获取bitmapBitmap bitmap2 = Bitmap.createBitmap(iv_bg.getDrawingCache());//裁剪bitmap2 = Bitmap.createBitmap(bitmap2, 0, jinyunView.getTop(), jinyunView.getWidth(), jinyunView.getHeight());//bitmap2传给surfaceViewjinyunView.setBitmapBg(bitmap2);//关闭DrawingCacheiv_bg.setDrawingCacheEnabled(false); 为什么要先获取背景视图的截图，而不直接用那个模糊化的图片呢，因为模糊化的图片尺寸超级小，显示的时候被放大了，而且可能还被裁剪了（背景用的imageView显示的），为保证裁剪后和背景重合还得做很多图象处理，还是直接获取截图来的简单 动态获取颜色关于三角形的颜色，其实也是要根据背景来设定的 Material Design鼓励使用动态颜色，新的Palette支持库可以提取图片中的一部分颜色来设置你的UI的样式来使界面颜色互相搭配以提供一种沉浸式体验。提取出来的调色板（palette）包括突出的和柔和的色调Vibrant （有活力）Vibrant dark（有活力 暗色）Vibrant light（有活力 亮色）Muted （柔和）Muted dark（柔和 暗色）Muted light（柔和 亮色） 就是可以从bitmap中获取几种特殊的颜色，注意获取到的swatche可能为空的 1234567891011121314// Palette的部分Palette palette = Palette.generate(bitmap);Palette.Swatch swatche = null;//获取不同风格的颜色，swatche = palette.getVibrantSwatch();swatche = palette.getLightVibrantSwatch();swatche = palette.getDarkVibrantSwatch();swatche = palette.getMutedSwatch();//我用这个和网易云接近，其他颜色也都挺漂亮swatche = palette.getLightMutedSwatch();swatche = palette.getDarkMutedSwatch();swatche = palette.getVibrantSwatch();//获取颜色int color = swatche.getRgb(); 视频效果：http://lc-fgtnb2h8.cn-n1.lcfile.com/7f08b2eea6a4039cf453.mp4换个颜色：http://lc-fgtnb2h8.cn-n1.lcfile.com/45e70109d2cbc9b7371b.mp4 改变图片的亮度但是发现一个问题，背景颜色太亮了，我选择palette.getLightMutedSwatch()是最亮的颜色，还是会被背景干扰，这个设置最上层的布局背景为半透明，发现我surfaceView也跟着被半透明覆盖了呀，如果只覆盖背景的话，surfaceView绘制的背景是从作为背景的ImageVIew截取的图片，会和背景颜色不一样的，只能从背景ImageView入手，还真的有改变亮度的办法，不仅可以改变亮度，还可以改变色相和饱和度 12345ColorMatrix colorMatrix = new ColorMatrix();//改变图片亮度colorMatrix.setScale(0.5f,0.5f,0.5f,1);ColorMatrixColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);iv_bg.setColorFilter(colorFilter); 改变了亮度后对动态获取颜色会有影响，亮色的可能获取不到了，获取颜色应该提前获取 开始画线仔细看了一下，先画围绕这个圆画很多点，隔一段一个点，然后把点用曲线圈起来就ok了，动的时候就是设置一个上下移动的距离，一个点变成两个，两个点先连线，然后同一侧的点重新连成曲线，感觉是是这样的，先试试 围绕圆画点这个就是直线和圆的交点问题，从-180度到180度，每间隔一个角度，取斜率计算交点，差不多是这个意思 12y = (Math.sin(angle) * circleR);x = (Math.cos(angle) * circleR); 画出来一看，这是什么情况，根本不均匀，没道理呀，原来是Math.sin(angle)和Math.cos(angle)里面的值指的是弧度，不是角度，所以转换一下 12y = (Math.sin(Math.toRadians(angle)) * circleR);x = (Math.cos(Math.toRadians(angle)) * circleR); 画贝塞尔曲线我先用二阶贝塞尔曲线把相邻的点连了起来，中间的点取的是两个点的圆弧中间的点，反正看起来是一个圆 12345Path path = new Path();path.moveTo(point.x, point.y);//画二阶贝塞尔曲线path.quadTo(bezierPoint.x, bezierPoint.y, next.x, next.y);canvas.drawPath(path, paint); 原理如下图 处理点的跳动到了最后一步，让点分裂成两个分别上下移动后，再次将同一边的连成曲线并将移动后的上下两个点连线，移动距离先取随机数，效果好了再看音频相关东西，这个有点难度，我尝试了很多次，都不是我想要的结果 看起来都失败了，感觉这个移动距离不能取随机数，最后一个看起来比较像是手动输入了一组均匀的数据，并且是直接画的直线 获取音频信息感觉模拟数据不行，还是先看看怎么获取音频信息；获取音频信息比较简单 1.使用MediaPlayer播放传入的音乐，并拿到mediaPlayerId2.使用Visualizer类拿到拿到MediaPlayer播放中的音频数据（wave/fft）3.将数据用自定义控件展现出来使用Visualizer需要录音的动态权限， 如果播放sd卡音频需要STORAGE权限 12&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; 播放音乐12345678MediaPlayer mediaPlayer = MediaPlayer.create(this, R.raw.music_wheresilove);mediaPlayer.setLooping(true);mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mediaPlayer) { mediaPlayer.start(); }}); Visualizer回调Visualizer.OnDataCaptureListener 有2个回调，一个用于显示FFT数据，展示不同频率的振幅，另一个用于显示声音的波形图 1234567891011private Visualizer.OnDataCaptureListener dataCaptureListener = new Visualizer.OnDataCaptureListener() { @Override public void onWaveFormDataCapture(Visualizer visualizer, final byte[] waveform, int samplingRate) { //到waveform为波形图数据 } @Override public void onFftDataCapture(Visualizer visualizer, final byte[] fft, int samplingRate) { //FFT数据，展示不同频率的振幅 } }; Visualizer 有两个比较重要的参数设置可视化数据的数据大小 范围[Visualizer.getCaptureSizeRange()[0]Visualizer.getCaptureSizeRange()1]设置可视化数据的采集频率 范围[0Visualizer.getMaxCaptureRate()] 123456789visualizer = new Visualizer(mediaPlayer.getAudioSessionId());//采样的最大值int captureSize = Visualizer.getCaptureSizeRange()[1]; //采样的频率int captureRate = Visualizer.getMaxCaptureRate() * 3 / 4;visualizer.setCaptureSize(captureSize);visualizer.setDataCaptureListener(dataCaptureListener, captureRate, true, true);visualizer.setScalingMode(Visualizer.SCALING_MODE_NORMALIZED);visualizer.setEnabled(true); 有一个很有意思的地方，如果audioSessionId设置为零，就直接获取系统的音频，这个很有意思，连蒙带猜搞出来的 1visualizer = new Visualizer(0); 这样纸我们就拿到了两组数据，波形图和频谱图，很显然频谱图是展示不同频率的振幅的，一般情况下只有少部分频率会变动，所以我选择波形图。 拿到的波形图是一个byte数组，里面也是类似每个点的振幅，我们把数组里的数据作为高度画一条线，排成一排正常画出来 12345678910111213141516//画音频线 private void drawAudioLine(Canvas canvas) { if (mPoints == null || mPoints.length &lt; mBytes.length * 4) { mPoints = new float[mBytes.length * 4]; } for (int i = 1; i &lt; pointSize; i++) { if (mBytes[i] &lt; 0) { mBytes[i] = 127; } mPoints[i * 4] = getWidth() * i / pointSize; mPoints[i * 4 + 1] = getHeight() / 2; mPoints[i * 4 + 2] = getWidth() * i / pointSize; mPoints[i * 4 + 3] = 2 + getHeight() / 2 - mBytes[i]; } canvas.drawLines(mPoints, mPaint); } 效果是这样纸，用另一个频谱图也差不多，就是变化的区域有点少 这样纸的话，那是不是我把它绕圆一圈，然后在按相反方向绕一圈，同样跳动的两个点连线，然后随便画画曲线是不是就ok啦；做完就发现里面的值太大了，都看不出来是个圆了，那就都减去一点高度什么的，调整一下大小；然后这次就先画一个三次贝塞尔曲线吧，画出来跟跟屎一样，这个曲线是真的难画呀，而且画的慢，看起来不是很流畅；我再次尝试用简单的方法画 折线的顶点时候用圆角，并没有什么乱用 1mPaint.setStrokeJoin(Paint.Join.ROUND); 设置path中的连接处有个角度，看起来接近了一些，不过还是差很远 12CornerPathEffect cornerPathEffect = new CornerPathEffect(130);mPaint.setPathEffect(cornerPathEffect); 视频效果：http://lc-fgtnb2h8.cn-n1.lcfile.com/fada1f97f943dd6e944d.mp4 其实可以看出来做法是没有问题的，但是必须先对数据进行处理才能得到想要的效果，但是具体怎么处理这个的确需要不断尝试；如果处理好可以做出更多更好看的效果； 其他效果（下载视频才能正常播放）：http://lc-hfysfg0s.cn-n1.lcfile.com/19962ada548649c692ed.mp4 上面的视频效果在github的之前的提交版本里，有兴趣可以找找，现在在不断尝试新的效果，有找到比较好的，会更新上来；有谁搞出炫酷的效果，希望大家不吝赐教 有想法的同学记得告诉我呀，使用前需要先播放音乐哦，声音不能设置太小 视频转Gif工具实现：https://www.jianshu.com/p/81cb36b610f4视频的裁剪其实也是上面这个项目的代码，但是暂时没有做功能，会更新项目地址：https://github.com/tyhjh/Jinyuneffect","link":"/2020/11/16/Android%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%B2%B8%E4%BA%91%E9%9F%B3%E6%95%88%E5%8A%A8%E6%95%88/"},{"title":"Android微信抢红包辅助","text":"阅读原文：https://www.jianshu.com/p/5a44b6eaba20 快到年底了，又到了拼手速抢红包的时候了；其实很早之前就做过抢红包软件了，包括QQ和微信；但是大家都懂的，自己一个月前写的代码现在看起来都像是一坨shit一样；所以自己开始重新写一个抢红包的软件（其实是因为实在是太简单了），只做微信，因为QQ发红包的确用的太少了，而且QQ红包花样也太多了，什么唱歌、画画、成语接龙… 目标 快，天下武功无坚不摧、唯快不破，肯定要比人的手速快 准，只要你手机解锁了，在任意一个界面都可以快速抢到红包 狠，其实狠不狠没什么关系了，最重要的是全自动，自己不用任何操作，不然怎么解放双手 稳，肯定要能一直抢红包，来一个抢一个，来两个抢两个，抢红包一时爽，一直抢一直爽； 手机配置要求 1. Android系统 7.0及以上，辅助功能7.0以上支持模拟点击，模拟点击不是必须的，但是对于实现**快**很重要 2. 手机不能太垃圾了，手机慢有外挂也发挥不出来呀 实现原理实现方法就是利用Android辅助功能，开启辅助功能相当于开启了一个服务，在手机界面改变的时候，就能监听到该页面的一些信息并且能拿到界面的一些控件，然后可以对控件进行模拟点击，从而实现我们想要的功能。 除此以外，不仅能够对获取到的控件进行模拟点击，在Android7.0及以上的版本，我们可以模拟任意位置的点击包括触摸、滑动等等，就是说我们可以实现任何人能够进行的操作，这个是很有用的，可以做出很多有意思的东西，如果再配上截图、录屏和图像识别，就更有意思了。 模拟点击，就是说我们的手机界面自己动，整个流程像是一只手在帮你操作一样的；其实我见过更牛逼的方法，连解锁都不需要直接就领了红包，界面没有任何变化的；感觉上是通过通信，发数据给微信服务器实现的，当然这种是需要root权限的，并且得去解析微信的通信协议，我自然没时间去搞（其实有时间也不一定能搞出来）。 具体实现辅助功能首先是辅助功能，新建一个Service继承AccessibilityService 1public class LuckMoneyService extends AccessibilityService 然后去AndroidManifest文件里面去注册一下这个Service 1234567891011&lt;service android:name=&quot;.service.LuckMoneyService&quot; android:label=&quot;小圆脸的红包助手&quot; android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.accessibilityservice&quot; android:resource=&quot;@xml/accessible_service_wx_config&quot; /&gt; &lt;/service&gt; 在meta-data节点下有个resource值，这是个xml文件，里面配置了该辅助的一些信息，在res目录下新建一个文件夹，名字叫xml，然后新建一个xml文件，名字和resource配置的一样就行了 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:accessibilityEventTypes=&quot;typeWindowStateChanged|typeWindowContentChanged|typeNotificationStateChanged&quot; android:accessibilityFeedbackType=&quot;feedbackAllMask&quot; android:accessibilityFlags=&quot;flagDefault|flagRetrieveInteractiveWindows|flagIncludeNotImportantViews|flagReportViewIds&quot; android:canRetrieveWindowContent=&quot;true&quot; android:canRequestFilterKeyEvents=&quot;true&quot; android:description=&quot;@string/wx_luck_money&quot; android:canRequestEnhancedWebAccessibility=&quot;true&quot; android:notificationTimeout=&quot;20&quot; android:packageNames=&quot;com.tencent.mm&quot; android:canPerformGestures=&quot;true&quot; /&gt; 里面配置了一些参数，比如notificationTimeout是指定多少毫秒监听一次界面变化的，packageNames是指定监听哪个应用的，删掉这个配置就是监听全局，建议一定要删除掉，我这里只是展示用，description是对于该辅助的描述，其他配置不管也罢。 然后在LuckMoneyService里面重写一下onAccessibilityEvent方法 1234@Override public void onAccessibilityEvent(AccessibilityEvent event) { //界面发生了变化 } 每当界面改变的时候就会回调这个方法，通过event我们就可以获取到界面的信息包括界面上的控件 简单的用法123456789101112//获取当前界面包名String packageName = event.getPackageName().toString();//获取当前类名String className = event.getClassName().toString();//获取当前界面父布局的控件AccessibilityNodeInfo accessibilityNodeInfo = getRootInActiveWindow();//在父布局里面根据子控件**显示的文字**找到该子控件List&lt;AccessibilityNodeInfo&gt; nodeInfoList = accessibilityNodeInfo.findAccessibilityNodeInfosByText(text);//在父布局里面根据子控件的**id**找到该子控件List&lt;AccessibilityNodeInfo&gt; nodeInfoList = accessibilityNodeInfo.findAccessibilityNodeInfosByViewId(id);//点击该控件nodeInfo.performAction(AccessibilityNodeInfo.ACTION_CLICK); 上面的操作都比较基础，根据控件显示的文字查找控件，找出来的肯定是TextView和Button了，根据ID查找控件，ID就是指的写布局文件的时候设置的控件的ID 模拟触摸模拟触摸就是可以模拟人的触摸动作，也比较简单 1234567protected void gestureOnScreen(Path path, long startTime, long duration, AccessibilityService.GestureResultCallback callback) { GestureDescription.Builder builde = new GestureDescription.Builder(); builde.addStroke(new GestureDescription.StrokeDescription(path, startTime, duration)); GestureDescription gestureDescription = builde.build(); dispatchGesture(gestureDescription, callback, null); } 可以看到需要传入path就是一个路径嘛，模拟滑动的路径，用canvas画过画的都知道这东西还是比较简单的，不清楚也没关系，继续看，startTime就是多久后开始模拟事件，duration就是该滑动的时间，其他回调什么的为空就可以了； 辅助功能能做的东西大概就上面这些了，接下来看看 微信应用外的红包处理首先实现在微信界面外怎么抢红包，在微信界面外有红包出现必然会在通知栏会显示微信红包（如果没开通知消息，那你自己开一下不就完事了吗），只需要在回调方法里面判断一下是不是通知消息，如果是通知消息，获取里面的信息，判断是不是微信红包通知消息，是就点击该消息，会自动跳转到聊天界面； 因为我们是监听界面变化来实现功能的，所以在一个界面触发了界面变化的时候，接下来的处理就应该交给下一个界面的方法了，所以微信界面外的操作就是这些了 1234567891011121314151617181920212223/** * 红包标识字段 */public static final String HONG_BAO_TXT = &quot;[微信红包]&quot;;//通知栏消息，判断是不是红包消息 if (event.getParcelableData() != null &amp;&amp; event.getParcelableData() instanceof Notification) { Notification notification = (Notification) event.getParcelableData(); //获取通知消息详情 String content = notification.tickerText.toString(); //解析消息 String[] msg = content.split(&quot;:&quot;); String text = msg[1].trim(); if (text.contains(HONG_BAO_TXT)) { PendingIntent pendingIntent = notification.contentIntent; try { //点击消息，进入聊天界面 pendingIntent.send(); } catch (PendingIntent.CanceledException e) { e.printStackTrace(); } } } 其中PendingIntent这个东西写过通知栏的都知道，这个是设置跳转到哪个界面的，所以直接调用它的方法就完成了界面跳转了 聊天界面的红包处理界面外的红包点击通知栏消息就来到了聊天界面，其实所有的界面都必须经过这个界面才能领取到红包，所以这个界面很重要； 实现思路是这样的，聊天消息肯定是一个列表控件，其实是个ListView，而且肯定有控件ID，我们获取到这个ListView，然后遍历它的每个消息（只能遍历到当前界面显示的），判断这个消息是不是微信红包，如果是，并且未被领取，而且这个红包还得是别人发的，不是自己发的，我们才去点击这个消息，触发界面变化，然后丢给下一个界面处理； 1234567891011121314151617181920212223242526272829303132333435363738394041424344 //获取聊天消息列表List控件 AccessibilityNodeInfo nodeInfo = findViewByID(DETAIL_CHAT_LIST_ID); //这个消息列表不为空，那么肯定在聊天详情页 if (nodeInfo != null) { //判断有没有未领取红包并进行点击 clickItem(nodeInfo); return; } /** * 进行消息列表未领取红包的点击 * * @param nodeInfo */private void clickItem(AccessibilityNodeInfo nodeInfo) { //遍历消息列表的每个消息 for (int i = 0; i &lt; nodeInfo.getChildCount(); i++) { //获取到子控件 AccessibilityNodeInfo nodeInfoChild = nodeInfo.getChild(i); //获取红包控件 AccessibilityNodeInfo target = findViewByID(nodeInfoChild, AUM_ID); //获取头像的控件 AccessibilityNodeInfo avatar = findViewByID(nodeInfoChild, AVATAR_ID); boolean selfLuckMoney = false; //获取头像的位置，判断红包是否是自己发的，自己发的不抢 if (avatar != null) { Rect rect = new Rect(); avatar.getBoundsInScreen(rect); if (rect.left &gt; screenWidth / 2) { selfLuckMoney = true; } } //如果不是自己发的红包，并且获取到的微信红包这个控件不为空 if (target != null &amp;&amp; !selfLuckMoney) { //已领取这个控件为空，红包还没有被领取 if (findViewByID(nodeInfoChild, AUL_ID) == null) { //点击红包控件 performViewClick(target); return; } } }} 里面每个细节都注释了，获取ListView控件，获取到了说明是在消息界面，获取到消息列表的每一个控件，根据 是否是红包消息，是否是别人发的，是否是未领取的三点，去判断是否是可以领取的红包，然后点击可领取的红包，到达弹出開的这个弹窗的界面； monitor如何获取这个ListView控件的ID呢，而我又是如何知道是ListView的呢，可以通过一个工具来实现，就是在sdk工具下面的一个叫monitor的工具，其实之前的AndroidStudio是带这个工具的，但是后来界面上是没有了，但是其实还在的 1/Users/Tyhj/Library/Android/sdk/tools/monitor 连上手机，打开这个工具，手机上打开你要查看的界面，点击工具手机的小手机的图标，就会截屏，显示出这个界面的信息 红包弹窗界面处理 同样的红包弹窗这个界面也是必须经过的，十分重要；你要说这个弹窗界面也比较简单，我们判断一下是不是这个界面，然后点击开不就完事儿了；测试可以发现，这个弹窗出现的时候，当前的界面className是这个 1234** * 红包弹出的class的名字 */private static final String ACTIVITY_DIALOG_LUCKYMONEY = &quot;com.tencent.mm.plugin.luckymoney.ui.LuckyMoneyNotHookReceiveUI&quot;; 事情没有这么容易，当我去获取这个開的这个控件的时候，发现为空，获取不到，其实整个弹窗都获取不到，遇到这个问题的人肯定不少； 12//获取開的控件布局AccessibilityNodeInfo target = findViewByID(&quot;com.tencent.mm:id/dan&quot;); 其实深究下去，发现获取根布局都为空了，测试发现必须等待一段时间再去获取这个弹窗才行，但是等多久呢，大概几百毫秒吧，不定时的，不同手机也不一定，那么随便设一个就不行，因为你时间设置小了，程序可能会卡在这里抢不了红包了，肯定不行；设置大了，行，但是影响速度呀。那么开个循环去获取直到获取到不为空行吗？不行，奇怪的就是你一次去获取为空了，之后获取都为空了；只有等待一段时间后第一次去获取才不为空，这TMD就很奇怪了，看了一下的确没法解决；这个问题其实和手机有关，在三星s9上的确有问题，在华为nova5 pro上没问题 12//获取根布局AccessibilityNodeInfo accessibilityNodeInfo = getRootInActiveWindow(); 如果获取不到，那其实还有个办法就是模拟点击，在红包弹窗弹出来的时候，我疯狂点击这个開字的位置，就行了；開字的位置可以通过屏幕比例来计算出来，这个就算不同的手机屏幕都可以点击到这个開字；但是其实还是有个问题，弹窗弹出其实有个动画，不同的手机其实弹出的时间也不不一样，华为nova5 pro都不用等待，可以直接执行点击操作，三星s9得等待200ms左右 123456789101112131415161718192021222324252627282930 //当前为红包弹出窗（那个开的那个弹窗） if (className.equals(ACTIVITY_DIALOG_LUCKYMONEY)) { //进行红包开点击 clickOpen(); return; }/** * 点击开红包按钮 */ private void clickOpen() { //等待红包弹窗完成，直接使用模拟点击比较快，根据手机性能等待响应的时长 SystemClock.sleep(100); for (int i = 0; i &lt; 20; i++) { SystemClock.sleep(10); //计算了一下这个開字在屏幕中的位置，按照屏幕比例计算 clickOnScreen(screenWidth / 2, screenHeight * POINT_Y_SCAL, 1, null); } /*AccessibilityNodeInfo target = findViewByID(&quot;com.tencent.mm:id/dan&quot;); if (target != null) { performViewClick(target); return; } else { //如果没有找到按钮，再进行模拟点击 for (int i = 0; i &lt; 20; i++) { SystemClock.sleep(10); clickOnScreen(screenWidth / 2, screenHeight * POINT_Y_SCAL, 1, null); } }*/ } 点击了这个開字后，进入了红包详情页，进行下一步处理。 红包详情页处理进入了红包详情页，红包已经到手了，想要继续抢红包，肯定需要退出去，这个简单，有返回键的方法；这时候你可以返回聊天界面继续抢这个群的红包(如果专抢一个群的，这样效率高)，也可以返回到最近消息列表（微信主页面第一个界面），可以抢其他群的红包（抢其多个群的红包，这样效率高），也可以退回手机主界面（抢红包效率低，因为还需要点击通知栏消息进去）；可以设置一下，如果开启专抢一个群，就退回该群聊天界面，否则退回最近消息列表界面。 1234567891011//红包领取后的详情页面，自动返回if (className.equals(LUCKY_MONEY_DETAIL)) { //返回聊天界面 performGlobalAction(GLOBAL_ACTION_BACK); //如果不是专抢一个群 if (!isSingle) { SystemClock.sleep(50); performGlobalAction(GLOBAL_ACTION_BACK); } return;} 最近消息列表界面处理 当领完红包后，退出到最近消息列表界面是比较好的选择；这个界面上当收到红包消息通知栏是不会有提醒的；我们需要根据界面的显示去判断有没有红包；其实也是特别简单，它也是一个ListView，同样的遍历一下每个item，判断有没有微信红包消息，然后点击进入聊天消息界面 123456789101112131415161718192021222324 //在最近聊天列表，检测有没有红包消息出现 nodeInfo = findViewByID(HUMAN_LIST); //联系人列表 if (nodeInfo != null) { //判断最近聊天列表有没有未领取红包 clickHumanItem(nodeInfo); return; } /** * 进行联系人列表的红包消息点击 * * @param nodeInfo */private void clickHumanItem(AccessibilityNodeInfo nodeInfo) { for (int i = 0; i &lt; nodeInfo.getChildCount(); i++) { AccessibilityNodeInfo nodeInfoChild = nodeInfo.getChild(i); AccessibilityNodeInfo target = findViewByID(nodeInfoChild, HUMAN_LIST_TXT_ID); if (target != null &amp;&amp; target.getText() != null &amp;&amp; target.getText().toString().contains(HONG_BAO_TXT)) { performViewClick(target); return; } }} 看似没有问题，实则有一个问题，就是在这个聊天列表里面，没法判断这个红包是别人发的还是你自己发的，如果是你自己发的那肯定有问题的，这是一个坑，当然可以通过保存一些数据，比如说第一次进去后发现是自己发的红包就退出来，如果界面没变化第二次就不再进行点击了；但是其实问题也不大吧，最多就是你发完红包后自己再发个消息就可以避免了。 测试总结其实到这里就全完成了，实际效果也不错，测了一下，4个人和一个辅助比，发了20次红包，辅助大概能抢到18次吧，并不是百分百抢到，主要是人有准备的话疯狂点屏幕其实也挺快的（单身20年的同学的手速不得不服，毕竟有个地方我还是sleep了100毫秒的，其实去掉应该更快的），一般情况下辅助还是有绝对优势的。 一般情况下感觉用到的这些控件ID、布局、界面所在的类、包名什么的是不太会改变的，当然如果微信版本升级比较大，估计布局什么的有变化，还得根据新的布局去重新实现，但是思路其实都是一样的。 更新更新前抢一次红包时间大概为1300毫秒左右，更新了弹窗等待那一步，不等待直接模拟点击一次也是可以的（自己手机测试通过），更新后时间减少到1000毫秒左右；自己测试手速抢红包，时间大概是1400毫秒以上，感觉真的比人手速快了 项目地址里面有一些方法是封装了的，方便调用，具体实现可以看代码原文地址：Android微信抢红包辅助github地址：Android微信抢红包辅助软件下载地址（老版本）：https://github.com/tyhjh/LuckMoney/raw/master/%E6%8A%A2%E7%BA%A2%E5%8C%85.apk","link":"/2020/11/17/Android%E5%BE%AE%E4%BF%A1%E6%8A%A2%E7%BA%A2%E5%8C%85%E8%BE%85%E5%8A%A9/"},{"title":"Android日志工具的设计","text":"日志工具日志工具是日常开发中必不可少的工具，日志工具的功能一方面是开发时的实时打印，用于进行调试；另一个方面就是输出日志文件，当程序运行出现异常的时候用于定位问题；之前在项目中负责了日志工具的开发工作，最近也有同事咨询日志性能相关的东西，感觉还是有些技巧可以总结一波的。 日志打印功能基本打印对于日志打印，Android提供了Log类用于日志打印，打印日志分不同的等级，便于日志工具的封装，一般使用带日志等级的方法进行打印，而不是直接调用相应等级的方法；其中需要注意的一点是当tag参数TextUtils.isEmpty()时，是不会进行打印输出的； 1234567891011/** * Low-level logging call. * @param priority The priority/type of this log message 日志等级 * @param tag Used to identify the source of a log message. It usually identifies TAG * the class or activity where the log call occurs. * @param msg The message you would like logged. 打印的信息 * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } 打印优化控制台打印出日志后，再根据日志找出打印的位置，代码比较多的时候还是比较耗时的，可以进行模仿AndroidStudio的Exception的打印，点击打印的时候就可以跳转到代码所对应的地方；点击跳转的日志打印固定格式如下 1&quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot;+ targetStackTrace.getLineNumber() + &quot;)&quot; 除此以外，还可以把当前线程和方法名打印出来 12345678910111213141516171819202122232425262728293031/** * 获取日志出处 * * @return */ private static String getTargetStackTraceElement() { StackTraceElement targetStackTrace = null; boolean shouldTrace = false; //获取线程堆栈转储的堆栈跟踪元素数组 StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace(); //遍历元素数组 for (StackTraceElement stackTraceElement : stackTrace) { //该对象是否是打印日志自身 boolean isLogMethod = stackTraceElement.getClassName().equals(LogUtils.class.getName()); //如果上一个对象是日志工具本身并且该对象不是则证明该对象就是使用日志工具的类 if (shouldTrace &amp;&amp; !isLogMethod) { //保存调用日志工具的对象 targetStackTrace = stackTraceElement; break; } //保存上一个对象是不是打印工具本身 shouldTrace = isLogMethod; } //获取线程名 String tName = Thread.currentThread().getName(); //获取调用日志工具执行的方法 String methodName = targetStackTrace.getMethodName(); //进行拼接 return tName + &quot; -&gt; &quot; + methodName + &quot;(&quot; + targetStackTrace.getFileName() + &quot;:&quot; + targetStackTrace.getLineNumber() + &quot;)&quot;; } 也可以在一次打印前后加上一些分割线，这样看起来会更直观、更易用；打印效果如下 具体实现是在进行日志打印的时候拿到线程堆栈转储的堆栈跟踪元素数组，这里面的信息是当前线程的堆栈信息；我们可以对比一下系统的异常输出日志，一般有异常抛出e.printStackTrace会全部输出到控制台，如下图所示；可以看出来第一个输出的是异常抛出的方法，之后都是上级的方法；同理我们获取到线程的堆栈信息后只想打印一下调用日志工具的地方的信息，就需要从这个stackTrace数组里面去找，取第一个的话肯定是日志工具类本身的方法，不是我们想要的，所以代码里面进行了判断，找第一个不是日志工具类的对象就好了；其实这里也可以根据代码直接写死取第几个对象，因为调用日志工具类的方法后执行的方法个数肯定是固定的； 除此以外还可以对特殊格式的字符串进行打印的优化，比如说提供对Json数据进行格式化打印的方法，这个看起来会很方便；具体的实现就是做一些简单的字符替换，网上一大堆这里就不再给出代码； 输入日志到文件输出日志到文件还是比较简单的，只需要开启一个输出流，将打印的日志输出到日志文件中即可； 12345678910111213/** * 写日志到文件，示例简化代码 * @param logMsg */ private void writeLogFile(String logMsg){ FileOutputStream fos = null; String logFilePath =&quot;sdcard/log.txt&quot;; File file = new File(logFilePath); fos = new FileOutputStream(file, true); fos.write(logMsg.getBytes()); //关闭流 fos.close(); } 多线程调用但是如果只是这样实现的话肯定是有问题的，写文件操作肯定是需要考虑性能的，每执行一次方法就会开启一个输出流，会对性能造成很大的影响，很容易出现内存溢出；因此只能开启一个输出流，可以将输出流设置为成员变量每次执行完以后不关闭，APP退出时再进行关闭；但是对于多线程调用，多个线程同时进行写文件操作也可能会出现问题，可以通过synchronized加锁来实现同步； 12345678910111213141516/** * 文件输出流 */ private FileOutputStream mOutputStream; /** * 写日志到文件，示例简化代码 * @param msg */ private synchronized void writeLogFile(String msg){ if(mOutputStream==null){ mOutputStream=new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); } mOutputStream.write(msg.getBytes()); mOutputStream.flush(); } 建立写入缓存区当日志频繁打印的时候，每次打印一行，会不停的执行文件写入操作，效率比较低，会对性能造成一定的影响；可以使用带缓冲区的输出流BufferedOutputStream设置一定的内存缓冲区大小，先把日志数据先写入缓冲区，等缓冲区满了，再把数据写到文件里，能够大量减少 IO 次数，提高效率；但是也是有缺点的，缓冲区设置的越大越能减少IO次数，但是当程序异常退出的时候缓冲区的日志就会丢失掉，设置越大，丢失的越多；下面会讲讲优化方法 123456789101112131415161718/** * 带缓冲区的输出流 */private BufferedOutputStream mOutputStream;/** * 写日志到文件，示例简化代码 * * @param msg */private synchronized void writeLogFile(String msg) { if (mOutputStream == null) { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); mOutputStream = new BufferedOutputStream(fileOutputStream,BUFF_SIZE); } byte[] bytes = msg.getBytes(); mOutputStream.write(bytes,0,bytes.length);} 线程优化写入日志到文件的操作是在子线程进行操作的，在执行加了锁后的方法writeLogFile是内部私有的方法，我们需要对外提供一个方法，因为写文件是个耗时操作，所以这个方法是需要在子线程执行，这时候肯定就会使用线程池；使用线程池就会有线程的创建和回收，日志打印频繁也会对性能造成一定的影响；可以创建一个独立的线程进行写入日志到文件的操作，创建一个缓存区，对外部提供的方法将日志都放在缓冲区里面，线程里面循环从缓存区里面去读出日志，写入到文件中；这个缓存区可以使用一个数组或集合来实现，只要保证读写和删除的效率高即可； 12345678910111213141516171819202122232425262728293031/** * 初始化日志工具，示例简化代码 */ public void init() { openWrite = true; new Thread(new Runnable() { @Override public void run() { FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;/sdcard/log.txt&quot;)); BufferedOutputStream mOutputStream = new BufferedOutputStream(fileOutputStream, BUFF_SIZE); while (openWrite) { if (msgCache.size() &gt; 0) { byte[] bytes=msgCache.get(0).getBytes(); mOutputStream.write(bytes,0,bytes.length); msgCache.remove(0); } } } }).start(); } /** * 将日志存入缓存区 * * @param msg */ public void writeLogFile(String msg) { if (msgCache.size() &lt; LOG_MSG_CACHE_SIZE) { msgCache.add(msg); } } 这里对于msgCache这个集合也做了大小限制，因为极端情况，如果一直添加日志字符串到集合里面也会造成内存溢出，所以可以设置一下集合的大小控制一下，对于溢出的日志会被舍弃，也算是一个异常处理；讲道理一般情况是不可能出现的，如果出现了不做处理程序的性能肯定也会出问题。做一下计算如果每条日志是20个汉字，就是60个字节，如果缓存区设置为1M的话，也是可以缓存2万多条日志了； 日志缓存区优化感觉上面的做法还是不是特别靠谱，虽然很少几率发生，但是毕竟丢弃日志还是不太友好的；这里可以通过阻塞队列ArrayBlockingQueue代替普通的集合进行存储，初始化的时候需要指定队列的大小，当队列满了的时候会阻塞处理直到队列有空间，就不会主动进行日志的丢弃； 1private ArrayBlockingQueue&lt;String&gt; mCacheLog = new ArrayBlockingQueue(2000); 日志文件压缩日志多了以后日志文件的清理肯定是必要的，不然随着运行时间的延长日志文件会无限大；那么为了保存更多、更久的日志就可以对日志文件进行压缩，Android自带的压缩可以节省大约10以上倍的存储空间 12345678910111213//简写代码//压缩后保存的文件的输出流FileOutputStream fos = new FileOutputStream(zipFile);ZipOutputStream zos = new ZipOutputStream(fos);//原日志文件的输入流BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));ZipEntry entry = new ZipEntry(&quot;&quot; + file.getName());zos.putNextEntry(entry);int count;byte[] buf = new byte[1024];while ((count = bis.read(buf)) != -1) { zos.write(buf, 0, count);} 内存映射文件上面只是一个非常普通的日志工具的实现，由于设置了缓冲区，当APP异常退出的时候就会导致日志的丢失；而且无论怎样优化还是避免不了文件的IO操作，这不是废话吗，功能就是写日志到文件，肯定避免不了； 其实还是有办法进行优化，就是mmap（一种内存映射文件的方法），即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系，函数原型如下 1void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); 实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。 mmap 的回写时机 内存不足 进程退出 调用 msync 或者 munmap 不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD) 这篇文章介绍的非常不错 Android-内存映射mmap 简单点就是说，mmap操作提供了一种机制，可以让用户程序对内核空间的文件进行读写操作，这种机制不需要再将文件数据从内核空间读写到用户空间，相较于普通的文件读写，减少了一次数据的拷贝，效率更高；而且在内存不足或者进程退出的时候，会将数据写入文件，避免日志丢失的情况； 具体实现可以在C++里面使用mmap函数来实现，就是上面那个函数原型；不过在Java中也提供了内存映射的实现，就是MappedByteBuffer；先看看MappedByteBuffer的用法 1234567RandomAccessFile raf = new RandomAccessFile(sFile, &quot;rw&quot;);raf = new RandomAccessFile(sFile, &quot;rw&quot;);//把文件从0开始到FILE_SIZE映射到内存中MappedByteBuffer mByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, 0, FILE_SIZE);byte[] msgbyte = msg.getBytes();//写入内容mByteBuffer.put(msgbyte); 可以把文件映射到内存中，获取到一个MappedByteBuffer对象，往这里面put数据就会写入到文件中；那么第一个问题，这个FILE_SIZE设置多大生成的日志文件就是多大；设置太大了，在日志没达到这个大小的时候应用退出，就浪费了，尤其是应用异常退出的时候，根本没机会对日志文件进行处理；设置小了，当日志文件达到这个大小的时候需要进行扩展，重新进行映射，这样的操作频繁了就会影响性能； 方案比较测试数据 15byte的日志执行10万次，也就是写入1.43M数据到文件 方案 耗时/ms 普通文件输出流耗时 16756 缓冲区大小为默认大小(8192)的输出流耗时 977 设置内存映射文件，初始映射大小为1M时耗时 1151 冷静分析就时间消耗来看，设置输出流缓冲区和内存映射性能差不多，比普通的输出流效率高了很多；讲道理，不应该是mmap这种黑科技应该要厉害一点吗？我原本也是这样认为的，毕竟内存映射那一大堆不太能懂的描述看起来很厉害的样子。但是我们可以冷静分析一波，具体原理可以看上面那篇Android-内存映射mmap的文章； 这里简单点讲，普通读写文件（就是输入输出流的write和read等操作）是将硬盘的文件加载到内核空间，再复制到用户空间，用户才获取到数据，复制了两遍（这个顺序是从硬盘读文件，反之则是写文件）；而mmap内存映射就是只需要将文件从硬盘加载到内核空间，只复制一次用户就可以拿到数据；所以mmap优势在于少复制一次；但是对于BufferedOutputStream呢，虽然写一次文件需要复制两次，效率低，但是好在我有缓存区呀，我是大大减少了写入的次数；单次写入效率低的问题，就被减小了呀；而再反观mmap虽然你写入的效率极高，但是你没有缓存区，写入的次数毕竟多呀；所以缓存区这个减少写入文件次数的对于效率的提升作用是非常大的，从测试耗时来看设置默认大小的缓存区对性能的提提升有17倍左右； 所以如果给mmap加一个缓冲区，性能肯定会更高，但是加了缓冲区，应用异常退出，日志就可能丢失；鱼和熊掌不可得兼，其实感觉mmap够了，效率够高又能防止日志丢失，好好写写MappedByteBuffer的使用的逻辑还是很不错的。 总结基本上这样的话日志工具应该就差不多能用了，具体实现逻辑的话还是要自己去实现，这里也只是谈到自己遇到的一些可以优化的点，感觉上还是比较简单的。","link":"/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"实现Android换肤","text":"之前看过一点关于Android换肤的文章，插件化、Hook、无缝换肤什么的，听起来好像很难的样子，也没有好好看；现在关于换肤的开源项目现在也比较多，但其实原理都差不多；最近看了一下，自己实现了一波，感觉还是很简单的样子；这里也只是讲讲换肤的原理，知道了原理每个点就可以快速学习，然后完成整个流程；具体实现可以看代码； 换肤原理换肤其实很简单，说白了就是修改View的属性，一般就是修改字体颜色、背景、图片等；如果是一个超级简单的界面，最简单的实现方式就是点击换肤的时候把每一个View都重新设置一下属性就完事了； View设置属性简单吧，问题就在于在实际项目中不可能手动去获取到每一个控件进行换肤，因为控件太多了；那么问题就变为如何获取到所有的控件进行属性设置；然后换肤，其实就是换一套皮肤，换一套资源文件对吧，如何去更换资源文件也是一个问题 使用theme实现Activity的theme属性肯定都有用过，theme里面可以设置各种属性，更改了theme里面的属性比如颜色，我们的导航栏什么的使用了theme里面的颜色属性的控件颜色都会改变；可以从这个点入手，设置不同的theme，然后更换theme就可以实现；但是有一个问题，设置theme只有在activity的setContentView之前才有效，所以要实现换肤必须得重启Activity才能实现，而且每次新增皮肤必须重新修改源码，重新打包，这种方法感觉不太行； 获取到所有View所以还是那个问题，如何获取到所有的View进行换肤处理；有一个点就是每个Activity都有setContentView方法，其实猜也能猜到，就是把xml布局解析成一个View对象；有点像AOP（面向切面编程）的思想，如果我们能从这个点切入，拿到每一个生成的View对象，我们就可以统一处理了； 那就是去看源码了，其实很简单，我的MainActivity继承至AppCompatActivity，跟着方法深入下去 12345@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... AppCompatActivity里面的方法，我们跟着layoutResID走，直到layoutResID变为View 1234@Overridepublic void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID);} AppCompatDelegate里面的抽象方法 1public abstract void setContentView(@LayoutRes int resId); AppCompatDelegateImpl里面的实现，其实看到LayoutInflater.from(mContext).inflate(resId, contentParent);这句代码就很熟悉了，我们也会经常使用它去加载布局； 123456789@Overridepublic void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged();} 还是一样跟着resId走到LayoutInflater里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); } } 走到这个方法是返回生成的View，那生成View肯定是在inflate(parser, root, attachToRoot);方法里面 1234567891011121314public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) { final Resources res = getContext().getResources(); if (DEBUG) { Log.d(TAG, &quot;INFLATING from resource: \\&quot;&quot; + res.getResourceName(resource) + &quot;\\&quot; (&quot; + Integer.toHexString(resource) + &quot;)&quot;); } final XmlResourceParser parser = res.getLayout(resource); try { return inflate(parser, root, attachToRoot); } finally { parser.close(); }} 找到了生成View的地方 12// Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); 继续看createViewFromTag方法，里面使用各种Factory去创建View 1234567891011121314151617181920212223242526272829try { View view; if (mFactory2 != null) { view = mFactory2.onCreateView(parent, name, context, attrs); } else if (mFactory != null) { view = mFactory.onCreateView(name, context, attrs); } else { view = null; } if (view == null &amp;&amp; mPrivateFactory != null) { view = mPrivateFactory.onCreateView(parent, name, context, attrs); } if (view == null) { final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try { if (-1 == name.indexOf('.')) { view = onCreateView(parent, name, attrs); } else { view = createView(name, null, attrs); } } finally { mConstructorArgs[0] = lastContext; } } return view; 好的，就是这里了，因为所有加载xml布局创建View的流程都会走到这里来，然后Factory只是一个接口，到这里后从逻辑也可以看出来可能会有不同的Factory去创建View，也就是说不能再深入下去了；我们只需要实现我们的Factory然后设置给mFactory2就可以获取到所有的View了，这里是一个Hook点； 那么问题来了，我们怎么去实现用Factory创建View，这里xml里面的东西已经解析完了，看这个方法的参数，有了attrs和控件类名name，我们自己用反射不就轻松的可以生成View吗； 123View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) { ... 还有有最简单的方法，其实系统原来已经实现了对吧，我们照着他写不就完事儿了吗；我们在这里打个断点，进入这个方法，他怎么实现我们就跟着写就完事儿了； 发现是在AppCompatDelegateImpl这个类实现的方法，好的直接看retur的地方，进去进入方法 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) { if (mAppCompatViewInflater == null) { TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme); String viewInflaterClassName = a.getString(R.styleable.AppCompatTheme_viewInflaterClass); if ((viewInflaterClassName == null) || AppCompatViewInflater.class.getName().equals(viewInflaterClassName)) { // Either default class name or set explicitly to null. In both cases // create the base inflater (no reflection) mAppCompatViewInflater = new AppCompatViewInflater(); } else { try { Class viewInflaterClass = Class.forName(viewInflaterClassName); mAppCompatViewInflater = (AppCompatViewInflater) viewInflaterClass.getDeclaredConstructor() .newInstance(); } catch (Throwable t) { Log.i(TAG, &quot;Failed to instantiate custom view inflater &quot; + viewInflaterClassName + &quot;. Falling back to default.&quot;, t); mAppCompatViewInflater = new AppCompatViewInflater(); } } } boolean inheritContext = false; if (IS_PRE_LOLLIPOP) { inheritContext = (attrs instanceof XmlPullParser) // If we have a XmlPullParser, we can detect where we are in the layout ? ((XmlPullParser) attrs).getDepth() &gt; 1 // Otherwise we have to use the old heuristic : shouldInheritContext((ViewParent) parent); } return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */ true, /* Read read app:theme as a fallback at all times for legacy reasons */ VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */ ); } 好的，终于看见最终的方法了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495final View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs, boolean inheritContext, boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) { final Context originalContext = context; // We can emulate Lollipop's android:theme attribute propagating down the view hierarchy // by using the parent's context if (inheritContext &amp;&amp; parent != null) { context = parent.getContext(); } if (readAndroidTheme || readAppTheme) { // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); } if (wrapContext) { context = TintContextWrapper.wrap(context); } View view = null; // We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) { case &quot;TextView&quot;: view = createTextView(context, attrs); verifyNotNull(view, name); break; case &quot;ImageView&quot;: view = createImageView(context, attrs); verifyNotNull(view, name); break; case &quot;Button&quot;: view = createButton(context, attrs); verifyNotNull(view, name); break; case &quot;EditText&quot;: view = createEditText(context, attrs); verifyNotNull(view, name); break; case &quot;Spinner&quot;: view = createSpinner(context, attrs); verifyNotNull(view, name); break; case &quot;ImageButton&quot;: view = createImageButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckBox&quot;: view = createCheckBox(context, attrs); verifyNotNull(view, name); break; case &quot;RadioButton&quot;: view = createRadioButton(context, attrs); verifyNotNull(view, name); break; case &quot;CheckedTextView&quot;: view = createCheckedTextView(context, attrs); verifyNotNull(view, name); break; case &quot;AutoCompleteTextView&quot;: view = createAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;MultiAutoCompleteTextView&quot;: view = createMultiAutoCompleteTextView(context, attrs); verifyNotNull(view, name); break; case &quot;RatingBar&quot;: view = createRatingBar(context, attrs); verifyNotNull(view, name); break; case &quot;SeekBar&quot;: view = createSeekBar(context, attrs); verifyNotNull(view, name); break; default: // The fallback that allows extending class to take over view inflation // for other tags. Note that we don't check that the result is not-null. // That allows the custom inflater path to fall back on the default one // later in this method. view = createView(context, name, attrs); } if (view == null &amp;&amp; originalContext != context) { // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); } if (view != null) { // If we have created a view, check its android:onClick checkOnClickListener(view, attrs); } return view; } 仔细看的话，它创建出来的控件都是androidx.appcompat.widget里面的一些比较新的控件，就是升了一下级；其实感觉mFactory2就是Google自己修改皮肤用的； 如果我们的MainActivity继承至Activity的话，同样打断点会进入到另一个创建View的方法；虽然看起来代码很复杂，我们只要记住我们只是来创建View的，其他我们不管，我们自己实现的时候也是这个道理，我们就是实现创建View的方法；所以直接看创建View很简单了，就是直接用反射，传入View的参数AttributeSet，new一个View出来 12345...Object[] args = mConstructorArgs;args[1] = attrs;final View view = constructor.newInstance(args);... 这里还有个问题，既然这里可能有不同的Factory来创建View，我们随便实现一个，去设置给mFactory2，那肯定只会用我们的mFactory2来创建了；那是不是有问题，那我们的MainActivity其实继承Activity还是AppCompatActivity都会走我们自己的方法了；那我们的这个Factory到底是应该照着AppCompatActivity走的方法来写还是Activity走的这个方法来写，或者还有其他的方法来写 其实问题不大，正常开发中我们一般只会选一个Activity来做我们的BaseActivity是吧，我们就按照BaseActivity继承的这种类型来写；而且不同的Activity也可以，因为每个Activity的LayoutInflater是不一样的，我们可以实现不同的Factory分别设置给不同的Activity的LayoutInflater就行了； 好的在这里我们实现自己的Factory去创建View对象，就可以趁机保存所有的对象，然后当我们想换肤的时候就可以把每一个对象的属性修改就可以了；至于这里View怎么保存，怎么销毁，怎么防止内存泄漏这些小问题简单提一下，全局监听一下Activity的生命周期就完事了 1application.registerActivityLifecycleCallbacks(new SkinActivityLifecycleCallbacks()); 更换资源文件如何更换资源文件？插件化换肤感觉是最好的方法，通过一个皮肤包，可以理解为我们更换了一套皮肤后重新打的一个apk包；这样点击换肤的时候，我们拿到每一个View控件，获取到当前View对应属性的资源的ID，然后通过这个ID去皮肤包里面获取出对应的资源对象，然后设置给当前View就完成了换肤； 这里面有一个点，就是我们没法更换我们运行的APP里面的资源文件，我们只是从皮肤包里面读取出相应的资源，比如图片，就是读取出Drawable对象，通过setImageDrawable设置给当前的View； 具体如何去读取其实很简单，就是AssetManager通过反射设置apk文件的路径，就可以拿到Resources对象，Resources就可以通过resId拿到各种资源对象； 123456789AssetManager assetManager = AssetManager.class.newInstance(); Method method = assetManager.getClass().getMethod(&quot;addAssetPath&quot;, String.class); method.setAccessible(true); method.invoke(assetManager, path); Resources resources = mApplication.getResources(); Resources skinRes = new Resources(assetManager, resources.getDisplayMetrics(), resources.getConfiguration()); //根据ID获取到资源文件Drawable drawable = skinRes.getDrawable(resId); 其实通过皮肤包来实现非常方便，不管是想内置几种皮肤还是上线后更新皮肤包都可以实现，而且不需要改动之前的代码； 整体流程总结一下，其实就是APP启动的时候，通过application.registerActivityLifecycleCallbacks();，监听Activity的生命周期；每个Activity启动的时候，获取Activity的布局加载器LayoutInflater，给它设置一个Factory，首先会用它去创建View，在创建的时候就会给View设置指定皮肤包里面的资源了；然后保存这个Activity里面的每一个View，当再次换肤的时候获取到每一个View，重新设置指定皮肤的资源；当然Activity销毁的时候肯定是要释放掉View的；大致的流程就是这样 缺点这个东西肯定是有缺点的，我们只是针对布局加载器LayoutInflater进行换肤，也就是说，只要是通过LayoutInflater创建的View我们都可以进行换肤；但是如果有些View是我们new出来的，是换不了的，解决方法也很简单，就是手动添加到换肤的View集合里面去； 第二是只换资源文件里面的属性，这没什么好说的，本来就是根据资源文件换肤； 第三就是和theme相关的控件颜色没法换，这个很简单，因为我们从皮肤包里面是获取不到theme对象的；其实获取到也没有办法，因为重新给Activity设置theme是必须重启Activity的；我自己各种看源码，各种反射搞了半天，发现这个东西的确是搞不定的，这个东西比较复杂，因为它不是一个具体的资源文件； 解决方法是在加载View的时候判断一下View，比如RadioButton或者TabLayout这种可以设置属性进去的就单独改改很简单，但是你要是涉及到那些只能跟随theme属性的控件比如Switch这种，那的确是换不了的，theme换不掉，没办法修改颜色； 1234567891011121314151617 if (view instanceof RadioButton) { if (isDrawable()) { RadioButton radioButton = (RadioButton) view; Drawable drawable = SkinResourcesUtils.getDrawable(attrValueRefId); radioButton.setButtonDrawable(drawable); } } if (view instanceof TabLayout) { TabLayout tl = (TabLayout) view; if (isColor()) { int color = SkinResourcesUtils.getColor(attrValueRefId); tl.setSelectedTabIndicatorColor(color); } } 只能说有相应的替代方案，做不到完美；包括自定义Factory也是一样的，包括自定义View也需要自己适配，换肤这种东西感觉没有一个万能的，完美的方案，只能是针对不同的项目有不同的解决方法； 其实还是不错了，有些问题虽然存在，但是实际项目中换肤应该都比较简单，随便写写，适配一下肯定没问题的； 项目地址：https://github.com/tyhjh/Skinpeeler","link":"/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/"}],"tags":[{"name":"网页","slug":"网页","link":"/tags/%E7%BD%91%E9%A1%B5/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"壁纸","slug":"壁纸","link":"/tags/%E5%A3%81%E7%BA%B8/"},{"name":"WallpaperService","slug":"WallpaperService","link":"/tags/WallpaperService/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"内存泄露","slug":"内存泄露","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"内存泄漏","slug":"内存泄漏","link":"/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"},{"name":"组件化","slug":"组件化","link":"/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"api","slug":"api","link":"/tags/api/"},{"name":"架构","slug":"架构","link":"/tags/%E6%9E%B6%E6%9E%84/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"插件化","slug":"插件化","link":"/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"注解","slug":"注解","link":"/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"框架","slug":"框架","link":"/tags/%E6%A1%86%E6%9E%B6/"},{"name":"辅助","slug":"辅助","link":"/tags/%E8%BE%85%E5%8A%A9/"},{"name":"脚本","slug":"脚本","link":"/tags/%E8%84%9A%E6%9C%AC/"},{"name":"自动化","slug":"自动化","link":"/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"服务器","slug":"服务器","link":"/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"局域网","slug":"局域网","link":"/tags/%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"name":"端口映射","slug":"端口映射","link":"/tags/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"name":"IP地址","slug":"IP地址","link":"/tags/IP%E5%9C%B0%E5%9D%80/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"clover","slug":"clover","link":"/tags/clover/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"},{"name":"内存映射","slug":"内存映射","link":"/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"},{"name":"换肤","slug":"换肤","link":"/tags/%E6%8D%A2%E8%82%A4/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"网络技术","slug":"网络技术","link":"/categories/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF/"},{"name":"黑苹果","slug":"黑苹果","link":"/categories/%E9%BB%91%E8%8B%B9%E6%9E%9C/"}]}