<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="theme-color" content="#123456"><meta name="generator" content="Hexo 4.2.0"><title>Android日志工具的设计 - Tyhj‘s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Tyhj‘s Blog"><meta name="msapplication-TileImage" content="/img/logo.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Tyhj‘s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="这是一篇关于日志工具的思考、设计、优化"><meta property="og:type" content="article"><meta property="og:title" content="Android日志工具的设计"><meta property="og:url" content="https://yorhp.gitee.io/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"><meta property="og:site_name" content="Tyhj‘s Blog"><meta property="og:description" content="这是一篇关于日志工具的思考、设计、优化"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://yorhp.gitee.io/cover/log.png"><meta property="article:published_time" content="2020-11-12T19:13:48.756Z"><meta property="article:modified_time" content="2020-11-15T11:20:39.539Z"><meta property="article:author" content="Tyhj"><meta property="article:tag" content="日志"><meta property="article:tag" content="内存映射"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/cover/log.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://yorhp.gitee.io/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"},"headline":"Tyhj‘s Blog","image":["https://yorhp.gitee.io/cover/log.png"],"datePublished":"2020-11-12T19:13:48.756Z","dateModified":"2020-11-15T11:20:39.539Z","author":{"@type":"Person","name":"Tyhj"},"description":"这是一篇关于日志工具的思考、设计、优化"}</script><link rel="canonical" href="https://yorhp.gitee.io/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"><link rel="icon" href="/img/logo.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/github.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Tyhj</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="HIK-LOL" href="http://hiklol.yorhp.com/"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Github" href="https://github.com/tyhjh"><i class="fab fa-github"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="简书" href="https://www.jianshu.com/u/4a982d7d261a?order_by=shared_at">简书</a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/cover/log.png" alt="Android日志工具的设计"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-11-12T19:13:48.756Z" title="2020-11-12T19:13:48.756Z">2020-11-13</time>发表</span><span class="level-item"><time dateTime="2020-11-15T11:20:39.539Z" title="2020-11-15T11:20:39.539Z">2020-11-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Android/">Android</a></span><span class="level-item">26 分钟读完 (大约3957个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Android日志工具的设计</h1><div class="content"><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><p>日志工具是日常开发中必不可少的工具，日志工具的功能一方面是开发时的实时打印，用于进行调试；另一个方面就是输出日志文件，当程序运行出现异常的时候用于定位问题；之前在项目中负责了日志工具的开发工作，最近也有同事咨询日志性能相关的东西，感觉还是有些技巧可以总结一波的。</p>
<!-- more -->

<h2 id="日志打印功能"><a href="#日志打印功能" class="headerlink" title="日志打印功能"></a>日志打印功能</h2><h3 id="基本打印"><a href="#基本打印" class="headerlink" title="基本打印"></a>基本打印</h3><p>对于日志打印，Android提供了Log类用于日志打印，打印日志分不同的等级，便于日志工具的封装，一般使用带日志等级的方法进行打印，而不是直接调用相应等级的方法；其中需要注意的一点是当<code>tag</code>参数<code>TextUtils.isEmpty()</code>时，是不会进行打印输出的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Low-level logging call.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> priority The priority/type of this log message 日志等级</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> tag Used to identify the source of a log message.  It usually identifies TAG</span></span><br><span class="line"><span class="comment">    *        the class or activity where the log call occurs.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> msg The message you would like logged. 打印的信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> The number of bytes written.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">println</span><span class="params">(<span class="keyword">int</span> priority, String tag, String msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> println(LOG_ID_MAIN, priority, tag, msg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="打印优化"><a href="#打印优化" class="headerlink" title="打印优化"></a>打印优化</h3><p>控制台打印出日志后，再根据日志找出打印的位置，代码比较多的时候还是比较耗时的，可以进行模仿AndroidStudio的Exception的打印，点击打印的时候就可以跳转到代码所对应的地方；点击跳转的日志打印固定格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;(&quot;</span> + targetStackTrace.getFileName() + <span class="string">&quot;:&quot;</span>+ targetStackTrace.getLineNumber() + <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>
<p>除此以外，还可以把当前线程和方法名打印出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取日志出处</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getTargetStackTraceElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      StackTraceElement targetStackTrace = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">boolean</span> shouldTrace = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//获取线程堆栈转储的堆栈跟踪元素数组</span></span><br><span class="line">      StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line">      <span class="comment">//遍历元素数组</span></span><br><span class="line">      <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">          <span class="comment">//该对象是否是打印日志自身</span></span><br><span class="line">          <span class="keyword">boolean</span> isLogMethod = stackTraceElement.getClassName().equals(LogUtils.class.getName());</span><br><span class="line">          <span class="comment">//如果上一个对象是日志工具本身并且该对象不是则证明该对象就是使用日志工具的类</span></span><br><span class="line">          <span class="keyword">if</span> (shouldTrace &amp;&amp; !isLogMethod) &#123;</span><br><span class="line">              <span class="comment">//保存调用日志工具的对象</span></span><br><span class="line">              targetStackTrace = stackTraceElement;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//保存上一个对象是不是打印工具本身</span></span><br><span class="line">          shouldTrace = isLogMethod;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取线程名</span></span><br><span class="line">      String tName = Thread.currentThread().getName();</span><br><span class="line">      <span class="comment">//获取调用日志工具执行的方法</span></span><br><span class="line">      String methodName = targetStackTrace.getMethodName();</span><br><span class="line">      <span class="comment">//进行拼接</span></span><br><span class="line">      <span class="keyword">return</span> tName + <span class="string">&quot; -&gt; &quot;</span> + methodName + <span class="string">&quot;(&quot;</span> + targetStackTrace.getFileName() + <span class="string">&quot;:&quot;</span></span><br><span class="line">              + targetStackTrace.getLineNumber() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>也可以在一次打印前后加上一些分割线，这样看起来会更直观、更易用；打印效果如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4906791-e6e60204fdf6f6ca.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>具体实现是在进行日志打印的时候拿到线程堆栈转储的堆栈跟踪元素数组，这里面的信息是当前线程的堆栈信息；我们可以对比一下系统的异常输出日志，一般有异常抛出<code>e.printStackTrace</code>会全部输出到控制台，如下图所示；可以看出来第一个输出的是异常抛出的方法，之后都是上级的方法；同理我们获取到线程的堆栈信息后只想打印一下调用日志工具的地方的信息，就需要从这个<code>stackTrace</code>数组里面去找，取第一个的话肯定是日志工具类本身的方法，不是我们想要的，所以代码里面进行了判断，找第一个不是日志工具类的对象就好了；其实这里也可以根据代码直接写死取第几个对象，因为调用日志工具类的方法后执行的方法个数肯定是固定的；<br><img src="https://upload-images.jianshu.io/upload_images/4906791-4645fd83069d6682.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="excption.PNG-56.8kB"></p>
<p>除此以外还可以对特殊格式的字符串进行打印的优化，比如说提供对Json数据进行格式化打印的方法，这个看起来会很方便；具体的实现就是做一些简单的字符替换，网上一大堆这里就不再给出代码；</p>
<h2 id="输入日志到文件"><a href="#输入日志到文件" class="headerlink" title="输入日志到文件"></a>输入日志到文件</h2><p>输出日志到文件还是比较简单的，只需要开启一个输出流，将打印的日志输出到日志文件中即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写日志到文件，示例简化代码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logMsg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeLogFile</span><span class="params">(String logMsg)</span></span>&#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        String logFilePath =<span class="string">&quot;sdcard/log.txt&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(logFilePath);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(file, <span class="keyword">true</span>);</span><br><span class="line">        fos.write(logMsg.getBytes());</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h3><p>但是如果只是这样实现的话肯定是有问题的，写文件操作肯定是需要考虑性能的，每执行一次方法就会开启一个输出流，会对性能造成很大的影响，很容易出现内存溢出；因此只能开启一个输出流，可以将输出流设置为成员变量每次执行完以后不关闭，APP退出时再进行关闭；但是对于多线程调用，多个线程同时进行写文件操作也可能会出现问题，可以通过<code>synchronized</code>加锁来实现同步；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 文件输出流</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> FileOutputStream mOutputStream;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 写日志到文件，示例简化代码</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLogFile</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(mOutputStream==<span class="keyword">null</span>)&#123;</span><br><span class="line">         mOutputStream=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;/sdcard/log.txt&quot;</span>));</span><br><span class="line">     &#125;</span><br><span class="line">     mOutputStream.write(msg.getBytes());</span><br><span class="line">     mOutputStream.flush();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立写入缓存区"><a href="#建立写入缓存区" class="headerlink" title="建立写入缓存区"></a>建立写入缓存区</h3><p>当日志频繁打印的时候，每次打印一行，会不停的执行文件写入操作，效率比较低，会对性能造成一定的影响；可以使用带缓冲区的输出流<code>BufferedOutputStream</code>设置一定的内存缓冲区大小，先把日志数据先写入缓冲区，等缓冲区满了，再把数据写到文件里，能够大量减少 IO 次数，提高效率；但是也是有缺点的，缓冲区设置的越大越能减少IO次数，但是当程序异常退出的时候缓冲区的日志就会丢失掉，设置越大，丢失的越多；下面会讲讲优化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带缓冲区的输出流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> BufferedOutputStream mOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写日志到文件，示例简化代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLogFile</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOutputStream == <span class="keyword">null</span>) &#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;/sdcard/log.txt&quot;</span>));</span><br><span class="line">        mOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream,BUFF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = msg.getBytes();</span><br><span class="line">    mOutputStream.write(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h3><p>写入日志到文件的操作是在子线程进行操作的，在执行加了锁后的方法<code>writeLogFile</code>是内部私有的方法，我们需要对外提供一个方法，因为写文件是个耗时操作，所以这个方法是需要在子线程执行，这时候肯定就会使用线程池；使用线程池就会有线程的创建和回收，日志打印频繁也会对性能造成一定的影响；可以创建一个独立的线程进行写入日志到文件的操作，创建一个缓存区，对外部提供的方法将日志都放在缓冲区里面，线程里面循环从缓存区里面去读出日志，写入到文件中；这个缓存区可以使用一个数组或集合来实现，只要保证读写和删除的效率高即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化日志工具，示例简化代码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      openWrite = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;/sdcard/log.txt&quot;</span>));</span><br><span class="line">              BufferedOutputStream mOutputStream = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream, BUFF_SIZE);</span><br><span class="line">              <span class="keyword">while</span> (openWrite) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (msgCache.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      <span class="keyword">byte</span>[] bytes=msgCache.get(<span class="number">0</span>).getBytes();</span><br><span class="line">                      mOutputStream.write(bytes,<span class="number">0</span>,bytes.length);</span><br><span class="line">                      msgCache.remove(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将日志存入缓存区</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLogFile</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (msgCache.size() &lt; LOG_MSG_CACHE_SIZE) &#123;</span><br><span class="line">          msgCache.add(msg);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里对于<code>msgCache</code>这个集合也做了大小限制，因为极端情况，如果一直添加日志字符串到集合里面也会造成内存溢出，所以可以设置一下集合的大小控制一下，对于溢出的日志会被舍弃，也算是一个异常处理；讲道理一般情况是不可能出现的，如果出现了不做处理程序的性能肯定也会出问题。做一下计算如果每条日志是20个汉字，就是60个字节，如果缓存区设置为1M的话，也是可以缓存2万多条日志了；</p>
<h3 id="日志缓存区优化"><a href="#日志缓存区优化" class="headerlink" title="日志缓存区优化"></a>日志缓存区优化</h3><p>感觉上面的做法还是不是特别靠谱，虽然很少几率发生，但是毕竟丢弃日志还是不太友好的；这里可以通过阻塞队列<code>ArrayBlockingQueue</code>代替普通的集合进行存储，初始化的时候需要指定队列的大小，当队列满了的时候会阻塞处理直到队列有空间，就不会主动进行日志的丢弃；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayBlockingQueue&lt;String&gt; mCacheLog = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="日志文件压缩"><a href="#日志文件压缩" class="headerlink" title="日志文件压缩"></a>日志文件压缩</h3><p>日志多了以后日志文件的清理肯定是必要的，不然随着运行时间的延长日志文件会无限大；那么为了保存更多、更久的日志就可以对日志文件进行压缩，Android自带的压缩可以节省大约10以上倍的存储空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简写代码</span></span><br><span class="line"><span class="comment">//压缩后保存的文件的输出流</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(zipFile);</span><br><span class="line">ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(fos);</span><br><span class="line"><span class="comment">//原日志文件的输入流</span></span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">ZipEntry entry = <span class="keyword">new</span> ZipEntry(<span class="string">&quot;&quot;</span> + file.getName());</span><br><span class="line">zos.putNextEntry(entry);</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((count = bis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    zos.write(buf, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>上面只是一个非常普通的日志工具的实现，由于设置了缓冲区，当APP异常退出的时候就会导致日志的丢失；而且无论怎样优化还是避免不了文件的IO操作，这不是废话吗，功能就是写日志到文件，肯定避免不了；</p>
<p>其实还是有办法进行优化，就是<strong>mmap</strong>（一种内存映射文件的方法），即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系，函数原型如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p>实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。</p>
<p>mmap 的回写时机</p>
<ul>
<li>内存不足</li>
<li>进程退出</li>
<li>调用 msync 或者 munmap</li>
<li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li>
</ul>
<blockquote>
<p>这篇文章介绍的非常不错 <a target="_blank" rel="noopener" href="https://blog.csdn.net/mcryeasy/article/details/86741781?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8">Android-内存映射mmap</a></p>
</blockquote>
<p>简单点就是说，mmap操作提供了一种机制，可以让用户程序对内核空间的文件进行读写操作，这种机制不需要再将文件数据从内核空间读写到用户空间，相较于普通的文件读写，减少了一次数据的拷贝，效率更高；而且在内存不足或者进程退出的时候，会将数据写入文件，避免日志丢失的情况；</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>可以在C++里面使用<code>mmap</code>函数来实现，就是上面那个函数原型；不过在Java中也提供了内存映射的实现，就是<strong>MappedByteBuffer</strong>；先看看MappedByteBuffer的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(sFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">raf = <span class="keyword">new</span> RandomAccessFile(sFile, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"><span class="comment">//把文件从0开始到FILE_SIZE映射到内存中</span></span><br><span class="line">MappedByteBuffer mByteBuffer = raf.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, FILE_SIZE);</span><br><span class="line"><span class="keyword">byte</span>[] msgbyte = msg.getBytes();</span><br><span class="line"><span class="comment">//写入内容</span></span><br><span class="line">mByteBuffer.put(msgbyte);</span><br></pre></td></tr></table></figure>

<p>可以把文件映射到内存中，获取到一个<strong>MappedByteBuffer</strong>对象，往这里面<code>put</code>数据就会写入到文件中；那么第一个问题，这个<code>FILE_SIZE</code>设置多大生成的日志文件就是多大；设置太大了，在日志没达到这个大小的时候应用退出，就浪费了，尤其是应用异常退出的时候，根本没机会对日志文件进行处理；设置小了，当日志文件达到这个大小的时候需要进行扩展，重新进行映射，这样的操作频繁了就会影响性能；</p>
<h3 id="方案比较"><a href="#方案比较" class="headerlink" title="方案比较"></a>方案比较</h3><p>测试数据 15byte的日志执行<strong>10万</strong>次，也就是写入<strong>1.43M</strong>数据到文件</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>耗时/ms</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件输出流耗时</td>
<td><strong>16756</strong></td>
</tr>
<tr>
<td>缓冲区大小为默认大小(8192)的输出流耗时</td>
<td><strong>977</strong></td>
</tr>
<tr>
<td>设置内存映射文件，初始映射大小为<strong>1M</strong>时耗时</td>
<td><strong>1151</strong></td>
</tr>
</tbody></table>
<h3 id="冷静分析"><a href="#冷静分析" class="headerlink" title="冷静分析"></a>冷静分析</h3><p>就时间消耗来看，设置输出流缓冲区和内存映射性能差不多，比普通的输出流效率高了很多；讲道理，不应该是<code>mmap</code>这种黑科技应该要厉害一点吗？我原本也是这样认为的，毕竟内存映射那一大堆不太能懂的描述看起来很厉害的样子。但是我们可以冷静分析一波，具体原理可以看上面那篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/mcryeasy/article/details/86741781?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-8">Android-内存映射mmap</a>的文章；</p>
<p>这里简单点讲，普通读写文件（就是输入输出流的<code>write</code>和<code>read</code>等操作）是将硬盘的文件加载到内核空间，再复制到用户空间，用户才获取到数据，复制了两遍（这个顺序是从硬盘读文件，反之则是写文件）；而<code>mmap</code>内存映射就是只需要将文件从硬盘加载到内核空间，只复制一次用户就可以拿到数据；所以<code>mmap</code>优势在于少复制一次；但是对于<code>BufferedOutputStream</code>呢，虽然写一次文件需要复制两次，效率低，但是好在我有缓存区呀，我是大大减少了写入的次数；单次写入效率低的问题，就被减小了呀；而再反观<code>mmap</code>虽然你写入的效率极高，但是你没有缓存区，写入的次数毕竟多呀；所以缓存区这个减少写入文件次数的对于效率的提升作用是非常大的，从测试耗时来看设置默认大小的缓存区对性能的提提升有17倍左右；</p>
<p>所以如果给<code>mmap</code>加一个缓冲区，性能肯定会更高，但是加了缓冲区，应用异常退出，日志就可能丢失；鱼和熊掌不可得兼，其实感觉<code>mmap</code>够了，效率够高又能防止日志丢失，好好写写<code>MappedByteBuffer</code>的使用的逻辑还是很不错的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上这样的话日志工具应该就差不多能用了，具体实现逻辑的话还是要自己去实现，这里也只是谈到自己遇到的一些可以优化的点，感觉上还是比较简单的。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Android日志工具的设计</p><p><a href="https://yorhp.gitee.io/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/">https://yorhp.gitee.io/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Tyhj</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2020-11-13</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2020-11-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E6%97%A5%E5%BF%97/">日志</a><a class="link-muted mr-2" rel="tag" href="/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/">内存映射</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">实现Android换肤</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/logo.png" alt="Tyhj"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Tyhj</p><p class="is-size-6 is-block">Talk is cheap, Show me the code</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>HIKVISION Inc.</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.jianshu.com/u/4a982d7d261a?order_by=top" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/tyhjh"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="FaceBook" href="https://www.jianshu.com/u/4a982d7d261a?order_by=top"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ号，tyhj5@qq.com" href="https://qm.qq.com/cgi-bin/qm/qr?k=36b9NfG1ak-LbuA3bvnxOlBD1vfspMRW&amp;noverify=0"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="微信号，yorhpx" href="/"><i class="fab fa-weixin"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="HIK-LOL" href="http://hiklol.yorhp.com/"><i class="fab fa-gitter"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#日志工具"><span class="level-left"><span class="level-item">1</span><span class="level-item">日志工具</span></span></a></li><li><a class="level is-mobile" href="#日志打印功能"><span class="level-left"><span class="level-item">2</span><span class="level-item">日志打印功能</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本打印"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">基本打印</span></span></a></li><li><a class="level is-mobile" href="#打印优化"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">打印优化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#输入日志到文件"><span class="level-left"><span class="level-item">3</span><span class="level-item">输入日志到文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#多线程调用"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">多线程调用</span></span></a></li><li><a class="level is-mobile" href="#建立写入缓存区"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">建立写入缓存区</span></span></a></li><li><a class="level is-mobile" href="#线程优化"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">线程优化</span></span></a></li><li><a class="level is-mobile" href="#日志缓存区优化"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">日志缓存区优化</span></span></a></li><li><a class="level is-mobile" href="#日志文件压缩"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">日志文件压缩</span></span></a></li><li><a class="level is-mobile" href="#内存映射文件"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">内存映射文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#具体实现"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">具体实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#方案比较"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">方案比较</span></span></a></li><li><a class="level is-mobile" href="#冷静分析"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">冷静分析</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">4</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="http://mikumiku.com.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">XANA</span></span><span class="level-right"><span class="level-item tag">mikumiku.com.cn</span></span></a></li><li><a class="level is-mobile" href="https://puppetsama.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">PuppetKant</span></span><span class="level-right"><span class="level-item tag">puppetsama.github.io</span></span></a></li><li><a class="level is-mobile" href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Icarus</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.zhangruipeng.me/hexo-theme-icarus/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Doc</span></span><span class="level-right"><span class="level-item tag">blog.zhangruipeng.me</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><figure class="media-left"><a class="image" href="/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/"><img src="/cover/skin.png" alt="实现Android换肤"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-11-14T22:16:33.888Z">2020-11-15</time></p><p class="title"><a href="/2020/11/15/%E5%AE%9E%E7%8E%B0Android%E6%8D%A2%E8%82%A4/">实现Android换肤</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/"><img src="/cover/log.png" alt="Android日志工具的设计"></a></figure><div class="media-content"><p class="date"><time dateTime="2020-11-12T19:13:48.756Z">2020-11-13</time></p><p class="title"><a href="/2020/11/13/Android%E6%97%A5%E5%BF%97%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1/">Android日志工具的设计</a></p><p class="categories"><a href="/categories/Android/">Android</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Android/"><span class="level-start"><span class="level-item">Android</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"><span class="tag">内存映射</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8D%A2%E8%82%A4/"><span class="tag">换肤</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"><span class="tag">插件化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%97%A5%E5%BF%97/"><span class="tag">日志</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Tyhj</a><p class="is-size-7"><span>&copy; 2020 Tyhj</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>    @copy-right<a target="_blank" rel="noopener" href="http://beian.miit.gov.cn"> 浙ICP备16033974号</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="HIK-LOL" href="http://hiklol.yorhp.com/"><i class="fab fa-gitter"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Github" href="https://github.com/tyhjh"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent " target="_blank" rel="noopener" title="简书" href="https://www.jianshu.com/u/4a982d7d261a?order_by=shared_at">简书</a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script src="/js/main.js" defer></script><!--!--></body></html>